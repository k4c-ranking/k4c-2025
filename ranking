/* Programming contest management system
 * Copyright © 2012 Luca Wehrstedt <luca.wehrstedt@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

var Chart = new function () {
    var self = this;

    self.draw_chart = function (canvas, y_min, y_max, y_def, h_def, x_int, data, color, marks) {
        // canvas is the context
/*
        canvas (GWTCanvas): the canvas this chart will be drawn on
        y_min (float): the y value corresponding to the bottom of the chart
        y_max (float): the y value corresponding to the top of the chart
            (note: y_min can be grater than y_max - the chart will be upside-down)
        y_def (float): the default y value (the line will start at that value)
        h_def (float): the default height of the colored area
        x_int (list of tuples of float): the list of x intervals to be drawn,
            in the form [begin, end)
        data (list of tuples of float): the data to be drawn, in the form (x, y, h)
        color (tuple of int): the r, g and b components of the color for the line
        marks (list of float): the y values at which horizontal lines will be drawn
*/

        // width and height
        var wid = canvas.width;
        var hei = canvas.height;

        // the padding around the chart
        var pad_l = 22;
        var pad_r = 1;
        var pad_t = 6;
        var pad_b = 6;

        // the intervals of allowed x values
        var x_size = 0;
        for (var i in x_int) {
            x_size += x_int[i][1] - x_int[i][0];
        }

        // convert values to canvas coordinates
        var get_x = function (x) {
            return pad_l + x * (wid - pad_l - pad_r) / x_size;
        };

        var get_y = function (y) {
            return pad_t + (y_max - y) * (hei - pad_t - pad_b) / (y_max - y_min == 0? 1: y_max - y_min);
        };

        // clear the canvas
        canvas.width = wid;

        // get the context
        var context = canvas.getContext("2d");

        // draw the axes
        context.lineWidth = 2;
        context.strokeStyle = "#dddddd";

        context.beginPath();
        context.moveTo(pad_l, pad_t);
        context.lineTo(pad_l, hei - pad_b);
        context.lineTo(wid - pad_r, hei - pad_b);
        context.lineTo(wid - pad_r, pad_t);
        context.stroke();

        // draw horizontal markers
        context.lineWidth = 1;
        context.moveTo(pad_l, pad_t);
        context.lineTo(wid - pad_r, pad_t);
        context.stroke();
        for (var i in marks) {
            context.beginPath();
            context.moveTo(get_x(0), get_y(marks[i]));
            context.lineTo(get_x(x_size), get_y(marks[i]));
            context.stroke();
        }

        // draw labels on the axes
        context.fillStyle = "#000000";
        context.textAlign = "right";
        context.textBaseline = "middle";
        if (y_min != y_max)
            context.fillText(y_min.toString(), 18, hei - pad_b);
        context.fillText(y_max.toString(), 18, pad_t);
        for (var i in marks) {
            context.fillText(marks[i].toString(), 18, get_y(marks[i]));
        }

        var i = 0  // index of current interval
        var x_cum = 0  // cumulated x value (sum of the size of the first i-1 intervals)
        var x_pos = 0  // current x value
        var y_pos = y_def  // current y value
        var h_pos = h_def  // current h value
        var x_b = 0  // the 'begin' value of the current interval
        var x_e = 0  // the 'end' value of the current interval

        var tops = [[x_pos, y_pos]]  // points of the line marking the top of the area
        var bots = [[x_pos, y_pos + h_pos]]  // points of the line marking the bottom

        // helper method to open an interval
        var open_group = function () {
            context.lineWidth = 2;
            context.strokeStyle = "rgb(" + color[0] + "," + color[1] + "," + color[2] + ")";
            context.beginPath();
            x_b = x_int[i][0];
            x_e = x_int[i][1];
            context.moveTo(get_x(x_pos), get_y(y_pos));
        }

        // helper method to close an interval
        var close_group = function () {
            x_cum += x_e - x_b;
            x_pos = x_cum;
            context.lineTo(get_x(x_pos), get_y(y_pos));
            tops.push([x_pos, y_pos]);
            bots.push([x_pos, y_pos + h_pos])
            context.stroke();
        }

        // helper method to draw a separator
        var draw_separator = function () {
            context.lineWidth = 2;
            context.strokeStyle = "#dddddd";
            context.beginPath();
            context.moveTo(get_x(x_pos), get_y(y_min));
            context.lineTo(get_x(x_pos), get_y(y_max));
            context.stroke();
        }

        open_group();

        for (var idx in data) {
            var x = data[idx][0];
            var y = data[idx][1];
            var h = data[idx][2];

            while (i < x_int.length && x_e <= x) {
                close_group();
                i += 1;
                if (i < x_int.length) {
                    draw_separator();
                    open_group();
                } else {
                    x_b = 0;
                    x_e = 0;
                }
            }
            if (x_b <= x && x < x_e) {
                x_pos = x_cum + x - x_b;
                context.lineTo(get_x(x_pos), get_y(y_pos));
                tops.push([x_pos, y_pos]);
                bots.push([x_pos, y_pos + h_pos]);
                y_pos = y;
                h_pos = h;
                context.lineTo(get_x(x_pos), get_y(y_pos));
                tops.push([x_pos, y_pos]);
                bots.push([x_pos, y_pos + h_pos]);
            } else {
                y_pos = y;
                h_pos = h;
                context.moveTo(get_x(x_pos), get_y(y_pos));
                tops.push([x_pos, y_pos]);
                bots.push([x_pos, y_pos + h_pos]);
            }
        }
        if (i < x_int.length) {
            close_group();
            i += 1;
        }
        while (i < x_int.length) {
            draw_separator();
            open_group();
            close_group();
            i += 1;
        }

        context.fillStyle = "rgba(" + color[0] + "," + color[1] + "," + color[2] + ",0.3)";
        context.beginPath();
        context.moveTo(get_x(tops[0][0]), get_y(tops[0][1]));
        for (var i = 0; i < tops.length; i += 1) {
            context.lineTo(get_x(tops[i][0]), get_y(tops[i][1]));
        }
        for (var i = bots.length - 1; i >= 0; i -= 1) {
            context.lineTo(get_x(bots[i][0]), get_y(bots[i][1]));
        }
        context.closePath();
        context.fill();
    };
};
/* Programming contest management system
 * Copyright © 2012 Luca Wehrstedt <luca.wehrstedt@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

var Config = new function () {
    var self = this;

    self.get_contest_list_url = function () {
        return "contests/";
    };

    self.get_contest_read_url = function (c_key) {
        return "contests/" + c_key;
    };

    self.get_task_list_url = function () {
        return "tasks/";
    };

    self.get_task_read_url = function (t_key) {
        return "tasks/" + t_key;
    };

    self.get_team_list_url = function () {
        return "teams/";
    };

    self.get_team_read_url = function (t_key) {
        return "teams/" + t_key;
    };

    self.get_user_list_url = function () {
        return "users/";
    };

    self.get_user_read_url = function (u_key) {
        return "users/" + u_key;
    };

    self.get_flag_url = function (t_key) {
        return "flags/" + t_key;
    };

    self.get_face_url = function (u_key) {
        return "faces/" + u_key;
    };

    self.get_submissions_url = function (u_key) {
        return "sublist/" + u_key;
    };

    self.get_score_url = function () {
        return "scores";
    };

    self.get_event_url = function (last_event_id) {
        return "events?last_event_id=" + last_event_id;
    };

    self.get_history_url = function () {
        return "history";
    }
};
/* Programming contest management system
 * Copyright © 2012 Luca Wehrstedt <luca.wehrstedt@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

function round(value, ndigits) {
    value *= Math.pow(10, ndigits);
    value = Math.round(value);
    value /= Math.pow(10, ndigits);
    return value;
}

function round_to_str(value, ndigits) {
    if (ndigits > 0) {
        // Remove trailing zeroes
        return value.toFixed(ndigits).replace(/\.?0+$/, "");
    } else {
        return value.toFixed(0);
    }
}

var DataStore = new function () {
    var self = this;

    self.contests = new Object();
    self.tasks = new Object();
    self.teams = new Object();
    self.users = new Object();

    self.contest_create = $.Callbacks();
    self.contest_update = $.Callbacks();
    self.contest_delete = $.Callbacks();
    self.task_create = $.Callbacks();
    self.task_update = $.Callbacks();
    self.task_delete = $.Callbacks();
    self.team_create = $.Callbacks();
    self.team_update = $.Callbacks();
    self.team_delete = $.Callbacks();
    self.user_create = $.Callbacks();
    self.user_update = $.Callbacks();
    self.user_delete = $.Callbacks();

    self.score_events = $.Callbacks();
    self.rank_events = $.Callbacks();


    ////// Contest

    self.contest_count = 0;

    self.init_contests = function () {
        $.ajax({
            url: Config.get_contest_list_url(),
            dataType: "json",
            success: function (data, status, xhr) {
                self.contest_init_time = parseFloat(xhr.getResponseHeader("Timestamp"));
                for (var key in data) {
                    self.create_contest(key, data[key]);
                }
                self.init_tasks();
            },
            error: function () {
                console.error("Error while getting the list of contests");
                self.update_network_status(4);
            }
        });
    }

    self.contest_listener = function (event) {
        var cmd = event.data.split(" ");
        if (cmd[0] == "create") {
            $.ajax({
                url: Config.get_contest_read_url(cmd[1]),
                dataType: "json",
                success: function (data) {
                    self.create_contest(cmd[1], data);
                },
                error: function () {
                    console.error("Error while getting contest " + cmd[1]);
                    self.es.close();
                    self.update_network_status(4);
                }
            });
        } else if (cmd[0] == "update") {
            $.ajax({
                url: Config.get_contest_read_url(cmd[1]),
                dataType: "json",
                success: function (data) {
                    self.update_contest(cmd[1], data);
                },
                error: function () {
                    console.error("Error while getting contest " + cmd[1]);
                    self.es.close();
                    self.update_network_status(4);
                }
            });
        } else if (cmd[0] == "delete") {
            self.delete_contest(cmd[1]);
        }
    };

    self.create_contest = function (key, data) {
        data["key"] = key;
        self.contests[key] = data;

        console.info("Created contest " + key);
        console.log(data);

        self.contest_count += 1;

        self.contest_create.fire(key, data);
    };

    self.update_contest = function (key, data) {
        var old_data = self.contests[key];

        data["key"] = key;
        self.contests[key] = data;

        console.info("Updated contest " + key);
        console.log(old_data);
        console.log(data);

        self.contest_update.fire(key, old_data, data);
    };

    self.delete_contest = function (key) {
        var old_data = self.contests[key];

        delete self.contests[key];

        console.info("Deleted contest " + key);
        console.log(old_data);

        self.contest_count -= 1;

        self.contest_delete.fire(key, old_data);
    };


    ////// Task

    self.task_count = 0;

    self.init_tasks = function () {
        $.ajax({
            url: Config.get_task_list_url(),
            dataType: "json",
            success: function (data, status, xhr) {
                self.task_init_time = parseFloat(xhr.getResponseHeader("Timestamp"));
                for (var key in data) {
                    self.create_task(key, data[key]);
                }
                self.inits_todo -= 1;
                if (self.inits_todo == 0) {
                    self.init_scores();
                }
            },
            error: function () {
                console.error("Error while getting the list of tasks");
                self.update_network_status(4);
            }
        });
    }

    self.task_listener = function (event) {
        var cmd = event.data.split(" ");
        if (cmd[0] == "create") {
            $.ajax({
                url: Config.get_task_read_url(cmd[1]),
                dataType: "json",
                success: function (data) {
                    self.create_task(cmd[1], data);
                },
                error: function () {
                    console.error("Error while getting task " + cmd[1]);
                    self.es.close();
                    self.update_network_status(4);
                }
            });
        } else if (cmd[0] == "update") {
            $.ajax({
                url: Config.get_task_read_url(cmd[1]),
                dataType: "json",
                success: function (data) {
                    self.update_task(cmd[1], data);
                },
                error: function () {
                    console.error("Error while getting task " + cmd[1]);
                    self.es.close();
                    self.update_network_status(4);
                }
            });
        } else if (cmd[0] == "delete") {
            self.delete_task(cmd[1]);
        }
    };

    self.create_task = function (key, data) {
        if (self.contests[data["contest"]] === undefined)
        {
            console.error("Could not find contest " + data["contest"] + " for task " + key);
            if (self.es) {
                self.es.close();
            }
            self.update_network_status(4);
            return;
        }

        data["key"] = key;
        self.tasks[key] = data;

        console.info("Created task " + key);
        console.log(data);

        self.task_count += 1;

        self.task_create.fire(key, data);
    };

    self.update_task = function (key, data) {
        var old_data = self.tasks[key];

        data["key"] = key;
        self.tasks[key] = data;

        console.info("Updated task " + key);
        console.log(old_data);
        console.log(data);

        self.task_update.fire(key, old_data, data);
    };

    self.delete_task = function (key) {
        var old_data = self.tasks[key];

        delete self.tasks[key];

        console.info("Deleted task " + key);
        console.log(old_data);

        self.task_count -= 1;

        self.task_delete.fire(key, old_data);
    };


    ////// Team

    self.team_count = 0;

    self.init_teams = function () {
        $.ajax({
            url: Config.get_team_list_url(),
            dataType: "json",
            success: function (data, status, xhr) {
                self.team_init_time = parseFloat(xhr.getResponseHeader("Timestamp"));
                for (var key in data) {
                    self.create_team(key, data[key]);
                }
                self.init_users();
            },
            error: function () {
                console.error("Error while getting the list of teams");
                self.update_network_status(4);
            }
        });
    }

    self.team_listener = function (event) {
        var cmd = event.data.split(" ");
        if (cmd[0] == "create") {
            $.ajax({
                url: Config.get_team_read_url(cmd[1]),
                dataType: "json",
                success: function (data) {
                    self.create_team(cmd[1], data);
                },
                error: function () {
                    console.error("Error while getting team " + cmd[1]);
                    self.es.close();
                    self.update_network_status(4);
                }
            });
        } else if (cmd[0] == "update") {
            $.ajax({
                url: Config.get_team_read_url(cmd[1]),
                dataType: "json",
                success: function (data) {
                    self.update_team(cmd[1], data);
                },
                error: function () {
                    console.error("Error while getting team " + cmd[1]);
                    self.es.close();
                    self.update_network_status(4);
                }
            });
        } else if (cmd[0] == "delete") {
            self.delete_team(cmd[1]);
        }
    };

    self.create_team = function (key, data) {
        data["key"] = key;
        self.teams[key] = data;

        console.info("Created team " + key);
        console.log(data);

        self.team_count += 1;

        self.team_create.fire(key, data);
    };

    self.update_team = function (key, data) {
        var old_data = self.teams[key];

        data["key"] = key;
        self.teams[key] = data;

        console.info("Updated team " + key);
        console.log(old_data);
        console.log(data);

        self.team_update.fire(key, old_data, data);
    };

    self.delete_team = function (key) {
        var old_data = self.teams[key];

        delete self.teams[key];

        console.info("Deleted team " + key);
        console.log(old_data);

        self.team_count -= 1;

        self.team_delete.fire(key, old_data);
    };


    ////// User

    self.user_count = 0;

    self.init_users = function () {
        $.ajax({
            url: Config.get_user_list_url(),
            dataType: "json",
            success: function (data, status, xhr) {
                self.user_init_time = parseFloat(xhr.getResponseHeader("Timestamp"));
                for (var key in data) {
                    self.create_user(key, data[key]);
                }
                self.inits_todo -= 1;
                if (self.inits_todo == 0) {
                    self.init_scores();
                }
            },
            error: function () {
                console.error("Error while getting the list of users");
                self.update_network_status(4);
            }
        });
    }

    self.user_listener = function (event) {
        var cmd = event.data.split(" ");
        if (cmd[0] == "create") {
            $.ajax({
                url: Config.get_user_read_url(cmd[1]),
                dataType: "json",
                success: function (data) {
                    self.create_user(cmd[1], data);
                },
                error: function () {
                    console.error("Error while getting user " + cmd[1]);
                    self.es.close();
                    self.update_network_status(4);
                }
            });
        } else if (cmd[0] == "update") {
            $.ajax({
                url: Config.get_user_read_url(cmd[1]),
                dataType: "json",
                success: function (data) {
                    self.update_user(cmd[1], data);
                },
                error: function () {
                    console.error("Error while getting user " + cmd[1]);
                    self.es.close();
                    self.update_network_status(4);
                }
            });
        } else if (cmd[0] == "delete") {
            self.delete_user(cmd[1]);
        }
    };

    self.create_user = function (key, data) {
        if (data["team"] !== null && self.teams[data["team"]] === undefined)
        {
            console.error("Could not find team " + data["team"] + " for user " + key);
            if (self.es) {
                self.es.close();
            }
            self.update_network_status(4);
            return;
        }

        data["key"] = key;
        self.users[key] = data;

        console.info("Created user " + key);
        console.log(data);

        self.user_count += 1;

        self.user_create.fire(key, data);
    };

    self.update_user = function (key, data) {
        var old_data = self.users[key];

        data["key"] = key;
        self.users[key] = data;

        console.info("Updated user " + key);
        console.log(old_data);
        console.log(data);

        self.user_update.fire(key, old_data, data);
    };

    self.delete_user = function (key) {
        var old_data = self.users[key];

        delete self.users[key];

        console.info("Deleted user " + key);
        console.log(old_data);

        self.user_count -= 1;

        self.user_delete.fire(key, old_data);
    };


    ////// Default scores

    self.global_max_score = 0.0;
    self.global_score_precision = 0;

    self.contest_create.add(function (key, data) {
        // Add scores
        for (var u_id in self.users) {
            self.users[u_id]["c_" + key] = 0.0;
        }
        // Maximum score
        data["max_score"] = 0.0;
        // Global score precision
        self.global_score_precision = 0;
        for (var c_id in self.contests) {
            self.global_score_precision = Math.max(self.global_score_precision, self.contests[c_id]["score_precision"]);
        }
    });

    self.contest_update.add(function (key, old_data, data) {
        // Maximum score
        data["max_score"] = old_data["max_score"];
        delete old_data["max_score"];
        // Global score precision
        self.global_score_precision = 0;
        for (var c_id in self.contests) {
            self.global_score_precision = Math.max(self.global_score_precision, self.contests[c_id]["score_precision"]);
        }
    });

    self.contest_delete.add(function (key, old_data) {
        // Remove scores
        for (var u_id in self.users) {
            delete self.users[u_id]["c_" + key];
        }
        // Maximum score
        delete old_data["max_score"];
        // Global score precision
        self.global_score_precision = 0;
        for (var c_id in self.contests) {
            self.global_score_precision = Math.max(self.global_score_precision, self.contests[c_id]["score_precision"]);
        }
    });

    self.task_create.add(function (key, data) {
        // Add scores
        for (var u_id in self.users) {
            self.users[u_id]["t_" + key] = 0.0;
        }
        // Maximum score
        self.contests[data["contest"]]["max_score"] += data["max_score"];
        self.global_max_score += data["max_score"];
    });

    self.task_update.add(function (key, old_data, data) {
        /* TODO: We may want to check that all scores are still less than or
           equal to the maximum achievable score. Or we may assume that this is
           handled by the server.
         */
        // Maximum score
        self.contests[old_data["contest"]]["max_score"] -= old_data["max_score"];
        self.global_max_score -= old_data["max_score"];
        self.contests[data["contest"]]["max_score"] += data["max_score"];
        self.global_max_score += data["max_score"];
    });

    self.task_delete.add(function (key, old_data) {
        // Remove scores
        for (var u_id in self.users) {
            delete self.users[u_id]["t_" + key];
        }
        // Maximum score
        self.contests[old_data["contest"]]["max_score"] -= old_data["max_score"];
        self.global_max_score -= old_data["max_score"];
    });

    self.user_create.add(function (key, data) {
        // Add scores
        for (var t_id in self.tasks) {
            data["t_" + t_id] = 0.0;
        }
        for (var c_id in self.contests) {
            data["c_" + c_id] = 0.0;
        }
        data["global"] = 0.0;
    });

    self.user_update.add(function (key, old_data, data) {
        // Copy scores
        for (var t_id in self.tasks) {
            data["t_" + t_id] = old_data["t_" + t_id];
            delete old_data["t_" + t_id];
        }
        for (var c_id in self.contests) {
            data["c_" + c_id] = old_data["c_" + c_id];
            delete old_data["c_" + c_id];
        }
        data["global"] = old_data["global"];
        delete old_data["global"];
    });

    self.user_delete.add(function (key, old_data) {
        // Remove scores
        for (var t_id in self.tasks) {
            delete old_data["t_" + t_id];
        }
        for (var c_id in self.contests) {
            delete old_data["c_" + c_id];
        }
        delete old_data["global"];
    });


    ////// Score

    self.init_scores = function () {
        $.ajax({
            url: Config.get_score_url(),
            dataType: "json",
            success: function (data, status, xhr) {
                self.score_init_time = parseFloat(xhr.getResponseHeader("Timestamp"));
                for (var u_id in data) {
                    for (var t_id in data[u_id]) {
                        self.set_score(u_id, t_id, data[u_id][t_id]);
                    }
                }
                self.init_ranks();
            },
            error: function () {
                console.error("Error while getting the scores");
                self.update_network_status(4);
            }
        });
    };

    self.score_listener = function (event) {
        var data = event.data.split("\n");
        for (var idx in data) {
            var line = data[idx].split(" ");
            self.set_score(line[0], line[1], parseFloat(line[2]));
        }
    };

    self.set_score = function (u_id, t_id, new_t_score) {
        /* It may be "nice" to check that the user and task do actually exists,
           even if the server should already ensure it!
         */
        var user = self.users[u_id];
        var task = self.tasks[t_id];

        var c_id = task["contest"];
        var contest = self.contests[c_id];

        // Task
        new_t_score = round(new_t_score, task["score_precision"]);
        var old_t_score = user["t_" + t_id];
        user["t_" + t_id] = new_t_score;

        // Contest
        var new_c_score = 0.0;  // = max(user's score on t for t in contest.tasks)
        for (var i = 0; i < contest.tasks.length; i += 1) {
            new_c_score += user["t_" + contest.tasks[i].key];
        }
        new_c_score = round(new_c_score, contest["score_precision"]);
        var old_c_score = user["c_" + c_id];
        user["c_" + c_id] = new_c_score;

        // Global
        var new_g_score = 0.0;  // = max(user's score on c for c in self.contest_list)
        for (var i = 0; i < self.contest_list.length; i += 1) {
            new_g_score += user["c_" + self.contest_list[i].key];
        }
        new_g_score = round(new_g_score, self.global_score_precision);
        var old_g_score = user["global"];
        user["global"] = new_g_score;

        console.info("Changed score for user " + u_id + " and task " + t_id + ": " + old_t_score + " -> " + new_t_score);

        self.score_events.fire(u_id, user, t_id, task, new_g_score - old_g_score);
    };

    self.get_score_t = function (u_id, t_id) {
        return self.users[u_id]["t_" + t_id];
    };

    self.get_score_c = function (u_id, c_id) {
        return self.users[u_id]["c_" + c_id];
    };

    self.get_score = function (u_id) {
        return self.users[u_id]["global"];
    };


    ////// Rank

    self.init_ranks = function () {
        // Make a list of all users
        var list = new Array();

        for (var u_id in self.users) {
            list.push(self.users[u_id]);
        }

        // Sort it by decreasing score
        list.sort(function (a, b) {
            return b["global"] - a["global"];
        });

        // Assign ranks
        var prev_score = null;
        var rank = 0;
        var equal = 1;

        for (var i in list) {
            user = list[i];
            score = user["global"];

            if (score === prev_score) {
                equal += 1;
            } else {
                prev_score = score;
                rank += equal;
                equal = 1;
            }

            user["rank"] = rank;
        }

        self.score_events.add(self.update_rank);

        self.user_create.add(function (u_id, user) {
            /* We're actually just counting how many users have a non-zero
               global score and setting the rank of the new user to that number
               plus one. An optimization could be to store that number and to
               keep it up-to-date (instead of computing it every time). But
               since user creation is a rare event we could keep it this way.
             */
            var new_rank = 1;

            for (var u_id in self.users) {
                if (self.users[u_id]["global"] > user["global"]) {
                    new_rank += 1;
                }
            }

            user["rank"] = new_rank;
        });

        self.user_update.add(function (u_id, old_user, user) {
            user["rank"] = old_user["rank"];
            delete old_user["rank"];
        });

        self.user_update.add(function (u_id, old_user) {
            /* We're assuming that the user has its score set to zero and thus
               has the highest possible rank (this is because the server should
               have already deleted all its submissions and subchanges). So its
              deletion won't cause changes in others' ranks.
             */
            delete old_user["rank"];
        });

        self.create_event_source();
        self.init_selections();
    };

    self.update_rank = function (u_id, user) {
        /* The rank of a user is defined as the number of other users that have
           a score greater than theirs, plus one. Note that:
               a.score < b.score if and only if a.rank > b.rank
               a.score = b.score if and only if a.rank = b.rank
               a.score > b.score if and only if a.rank < b.rank
           Thus it's the same to sort by ascending score or by descending rank,
           and vice versa.
           When a user's score is updated (e.g. it changes from old_score to
           new_score with new_score > old_score) it can be shown that:
             - all users whose score is >= new_score don't change their rank
             - all users whose score is < old_score don't change their rank
             - all other users have their rank increased by exactly one
           A similar proposition holds when new_score < old_score.
         */

        // We don't know old_score but we'll see that it's not needed.
        var new_score = user["global"];
        var old_rank = user["rank"];
        // The new rank is computed by strictly applying the definition:
        //     new_rank = 1 + |{user2 in users, user2.score > user.score}|
        var new_rank = 1;

        for (var u2_id in self.users) {
            var user2 = self.users[u2_id];
            // this condition is equivalent to
            //     old_score <= user2["global"] < new_score
            if (old_rank >= user2["rank"] && user2["global"] < new_score) {
                user2["rank"] += 1;
                self.rank_events.fire(u2_id, user2, +1);
            // this condition is equivalent to
            //     new_score <= user2["global"] < old_score
            } else if (new_score <= user2["global"] && user2["rank"] > old_rank) {
                user2["rank"] -= 1;
                self.rank_events.fire(u2_id, user2, -1);
            }
            if (user2["global"] > new_score) {
                new_rank += 1;
            }
        }

        user["rank"] = new_rank;

        if (old_rank != new_rank) {
            console.info("Changed rank for user " + u_id + ": " + old_rank + " -> " + new_rank);

            self.rank_events.fire(u_id, user, new_rank - old_rank);
        }
    };


    ////// Initialization

    /* The init process works this way:
       - we start init_contests() and init_teams()
       - they each start an asynchronous AJAX request
       - when the requests end their data is processed and then, respectively,
         init_tasks() and init_users() are called
       - they also start an AJAX request and process its data
       - when BOTH requests finish init_scores() is called
       - it does again an AJAX request and processes its data
       - at the end it calls init_ranks() which calls init_selections() which,
         in turn, calls init_callback()
     */

    self.init = function (callback) {
        self.inits_todo = 2;
        self.init_callback = callback;

        self.init_contests();
        self.init_teams();
    };


    ////// Event listeners

    /* We set the listeners for Server Sent Events. */

    self.last_event_id = null;

    self.create_event_source = function () {
        if (self.last_event_id == null) {
            self.last_event_id = Math.round(Math.min(self.contest_init_time,
                                                     self.task_init_time,
                                                     self.team_init_time,
                                                     self.user_init_time,
                                                     self.score_init_time) * 1000000).toString(16);
        }

        if (self.es) {
            delete self.es;
        }

        self.es = new EventSource(Config.get_event_url(self.last_event_id));

        self.es.addEventListener("open", self.es_open_handler, false);
        self.es.addEventListener("error", self.es_error_handler, false);
        self.es.addEventListener("reload", self.es_reload_handler, false);
        self.es.addEventListener("contest", function (event) {
            var timestamp = parseInt(event.lastEventId, 16) / 1000000;
            if (timestamp > self.contest_init_time) {
                self.contest_listener(event);
            }
            self.last_event_id = event.lastEventId;
        }, false);
        self.es.addEventListener("task", function (event) {
            var timestamp = parseInt(event.lastEventId, 16) / 1000000;
            if (timestamp > self.task_init_time) {
                self.task_listener(event);
            }
            self.last_event_id = event.lastEventId;
        }, false);
        self.es.addEventListener("team", function (event) {
            var timestamp = parseInt(event.lastEventId, 16) / 1000000;
            if (timestamp > self.team_init_time) {
                self.team_listener(event);
            }
            self.last_event_id = event.lastEventId;
        }, false);
        self.es.addEventListener("user", function (event) {
            var timestamp = parseInt(event.lastEventId, 16) / 1000000;
            if (timestamp > self.user_init_time) {
                self.user_listener(event);
            }
            self.last_event_id = event.lastEventId;
        }, false);
        self.es.addEventListener("score", function (event) {
            var timestamp = parseInt(event.lastEventId, 16) / 1000000;
            if (timestamp > self.score_init_time) {
                self.score_listener(event);
            }
            self.last_event_id = event.lastEventId;
        }, false);
    };

    self.update_network_status = function (state) {
        if (state == 0) { // self.es.CONNECTING
            $("#ConnectionStatus_box").attr("data-status", "reconnecting");
            $("#ConnectionStatus_text").text("You are disconnected from the server but your browser is trying to connect.");
        } else if (state == 1) { // self.es.OPEN
            $("#ConnectionStatus_box").attr("data-status", "connected");
            $("#ConnectionStatus_text").text("You are connected to the server and are receiving live updates.");
        } else if (state == 2) { // self.es.CLOSED
            $("#ConnectionStatus_box").attr("data-status", "disconnected");
            $("#ConnectionStatus_text").html("You are disconnected from the server but you can <a onclick=\"DataStore.create_event_source();\">try to connect</a>.");
        } else if (state == 3) { // "reload" event received
            $("#ConnectionStatus_box").attr("data-status", "outdated");
            $("#ConnectionStatus_text").html("Your local data cannot be updated. Please <a onclick=\"window.location.reload();\">reload the page</a>.");
        } else if (state == 4) { // an init failed
            $("#ConnectionStatus_box").attr("data-status", "init_error");
            $("#ConnectionStatus_text").html("An error occurred while loading the data. Check your connection and <a onclick=\"window.location.reload();\">reload the page</a>.");
        }
    };

    self.es_open_handler = function () {
        if (self.es.readyState == self.es.OPEN) {
            console.info("EventSource connected");
            self.update_network_status(self.es.readyState);
        } else {
            console.error("EventSource shouldn't be in state " + self.es.readyState + " during a 'open' event!");
        }
    };

    self.es_error_handler = function () {
        if (self.es.readyState == self.es.CONNECTING) {
            console.info("EventSource reconnecting");
            self.update_network_status(self.es.readyState);
        } else if (self.es.readyState == self.es.CLOSED) {
            console.info("EventSource disconnected");
            self.update_network_status(self.es.readyState);
        } else {
            console.error("EventSource shouldn't be in state " + self.es.readyState + " during a 'error' event!");
        }
    };

    self.es_reload_handler = function () {
        if (self.es.readyState == self.es.OPEN) {
            console.info("Received a 'reload' event");
            self.es.close();
            self.update_network_status(3);
        } else {
            console.error("EventSource shouldn't be in state " + self.es.readyState + " during a 'reload' event!");
        }
    };

    $(document).ready(function () {
        self.update_network_status(0);
    });


    ////// Sorted contest list

    self.contest_list = new Array();

    self.contest_list_insert = function (key, data) {
        // Insert data in the sorted contest list
        var a = data;
        for (var i = 0; i < self.contest_list.length; i += 1) {
            var b = self.contest_list[i];
            if ((a["begin"] < b["begin"]) || ((a["begin"] == b["begin"]) &&
               ((a["end"]   < b["end"]  ) || ((a["end"]   == b["end"]  ) &&
               ((a["name"]  < b["name"] ) || ((a["name"]  == b["name"] ) &&
               (key < b["key"]))))))) {
                // We found the first element which is greater than a
                self.contest_list.splice(i, 0, a);
                return;
            }
        }
        self.contest_list.push(a);
    };

    self.contest_list_remove = function (key, old_data) {
        // Remove data from the sorted contest list
        for (var i = 0; i < self.contest_list.length; i += 1) {
            var b = self.contest_list[i];
            if (key == b["key"]) {
                self.contest_list.splice(i, 1);
                return;
            }
        }
    };

    self.contest_create.add(function (key, data) {
        data["tasks"] = new Array();
        self.contest_list_insert(key, data);
    });
    self.contest_update.add(function (key, old_data, data) {
        data["tasks"] = old_data["tasks"];
        delete old_data["tasks"];
        self.contest_list_remove(key, old_data);
        self.contest_list_insert(key, data);
    });
    self.contest_delete.add(function (key, old_data) {
        delete old_data["tasks"];
        self.contest_list_remove(key, old_data);
    });


    ////// Sorted task list

    self.task_list_insert = function (key, data) {
        var task_list = self.contests[data["contest"]]["tasks"];

        // Insert data in the sorted task list of the contest
        var a = data;
        for (var i = 0; i < task_list.length; i += 1) {
            var b = task_list[i];
            if ((a["order"] < b["order"]) || ((a["order"] == b["order"]) &&
               ((a["name"]  < b["name"] ) || ((a["name"]  == b["name"] ) &&
               (key < b["key"]))))) {
                // We found the first element which is greater than a
                task_list.splice(i, 0, a);
                return;
            }
        }
        task_list.push(a);
    };

    self.task_list_remove = function (key, old_data) {
        var task_list = self.contests[old_data["contest"]]["tasks"];

        // Remove data from the sorted task list of the contest
        for (var i = 0; i < task_list.length; i += 1) {
            var b = task_list[i];
            if (key == b["key"]) {
                task_list.splice(i, 1);
                break;
            }
        }
    };

    self.task_create.add(self.task_list_insert);
    self.task_update.add(function (key, old_data, data) {
        self.task_list_remove(key, old_data);
        self.task_list_insert(key, data);
    });
    self.task_delete.add(self.task_list_remove);


    ////// Sorted team list

    self.team_list = new Array();

    self.team_list_insert = function (key, data) {
        // Insert data in the sorted team list
        var a = data;
        for (var i = 0; i < self.team_list.length; i += 1) {
            var b = self.team_list[i];
            if ((a["name"] < b["name"]) || ((a["name"] == b["name"]) &&
                (key < b["key"]))) {
                // We found the first element which is greater than a
                self.team_list.splice(i, 0, a);
                return;
            }
        }
        self.team_list.push(a);
    };

    self.team_list_remove = function (key, old_data) {
        // Remove data from the sorted team list
        for (var i = 0; i < self.team_list.length; i += 1) {
            var b = self.team_list[i];
            if (key == b["key"]) {
                self.team_list.splice(i, 1);
                break;
            }
        }
    }

    self.team_create.add(function (key, data) {
        data["users"] = new Array();
        self.team_list_insert(key, data);
    });
    self.team_update.add(function (key, old_data, data) {
        data["users"] = old_data["users"];
        delete old_data["users"];
        self.team_list_remove(key, old_data);
        self.team_list_insert(key, data);
    });
    self.team_delete.add(function (key, old_data) {
        delete old_data["users"];
        self.team_list_remove(key, old_data);
    });


    ////// Sorted user list

    self.user_list_insert = function (key, data) {
        if (data["team"] == null) {
            return;
        }

        var user_list = self.teams[data["team"]]["users"];

        // Insert data in the sorted user list of the team
        var a = data;
        for (var i = 0; i < user_list.length; i += 1) {
            var b = user_list[i];
            if ((a["l_name"] < b["l_name"]) || ((a["l_name"] == b["l_name"]) &&
               ((a["f_name"] < b["f_name"]) || ((a["f_name"] == b["f_name"]) &&
               (key < b["key"]))))) {
                // We found the first element which is greater than a
                user_list.splice(i, 0, a);
                return;
            }
        }
        user_list.push(a);
    };

    self.user_list_remove = function (key, old_data) {
        if (old_data["team"] == null) {
            return;
        }

        var user_list = self.teams[old_data["team"]]["users"];

        // Remove data from the sorted user list of the team
        for (var i = 0; i < user_list.length; i += 1) {
            var b = user_list[i];
            if (key == b["key"]) {
                user_list.splice(i, 1);
                break;
            }
        }
    };

    self.user_create.add(self.user_list_insert);
    self.user_update.add(function (key, old_data, data) {
        self.user_list_remove(key, old_data);
        self.user_list_insert(key, data);
    });
    self.user_delete.add(self.user_list_remove);


    ////// Selection

    self.select_events = $.Callbacks();

    /* We use eight different colors. We keep track of how many times each
       color is in use and when we have to assign a new color to an user we
       choose the one that has been used less times.
     */

    self.colors = [0,0,0,0,0,0,0,0]

    self.choose_color = function () {
        var min_idx = 0;
        for (var i = 1; i < 8; i += 1)
        {
            if (self.colors[i] < self.colors[min_idx])
            {
                min_idx = i;
            }
        }
        // Color indexes will be 1-based, so we add 1 to the result
        return min_idx+1;
    }

    self.init_selections = function () {
        $.each(self.users, function (u_id) {
            var color_idx = parseInt(localStorage.getItem("cms.rws.selection.users." + u_id));
            if (color_idx > 0)
            {
                self.set_selected(u_id, true, color_idx);
            }
        });

        $(window).on("storage", function (event) {
            event = event.originalEvent;
            if (event.storageArea == localStorage)
            {
                if (event.key === null)
                {
                    // Triggered by a .clear().
                    $.each(self.users, function (u_id) {
                        self.set_selected(u_id, false);
                    });
                }
                else if (event.key.lastIndexOf("cms.rws.selection.users.", 0) === 0)
                {
                    var u_id = event.key.substr(24);
                    if (event.oldValue === null && event.newValue !== null)
                    {
                        self.set_selected(u_id, true, parseInt(event.newValue));
                    }
                    else if (event.oldValue !== null && event.newValue === null)
                    {
                        self.set_selected(u_id, false);
                    }
                }
            }
        });

        self.init_callback();
    };

    self.set_selected = function (u_id, flag, color_idx) {
        if (self.users[u_id]["selected"] == 0 && flag) {
            // We have to assign a color
            if (!(color_idx > 0))
            {
                color_idx = self.choose_color();
            }
            self.users[u_id]["selected"] = color_idx;
            self.colors[color_idx-1] += 1;
            localStorage.setItem("cms.rws.selection.users." + u_id, color_idx);
            self.select_events.fire(u_id, color_idx);
        }
        else if (self.users[u_id]["selected"] != 0 && !flag) {
            // We have to remove the color
            var color_idx = self.users[u_id]["selected"];
            self.users[u_id]["selected"] = 0;
            self.colors[color_idx-1] -= 1;
            localStorage.removeItem("cms.rws.selection.users." + u_id);
            self.select_events.fire(u_id, 0);
        }
    };

    self.toggle_selected = function (u_id) {
        self.set_selected(u_id, self.users[u_id]["selected"] == 0);
    };

    self.get_selected = function (u_id) {
        return self.users[u_id]["selected"];
    };

    self.user_create.add(function (key, data) {
        data["selected"] = 0;
    });

    self.user_update.add(function (key, old_data, data) {
        data["selected"] = old_data["selected"];
        delete old_data["selected"];
    });

    self.user_delete.add(function (key, old_data) {
        self.set_selected(key, false);
        delete old_data["selected"];
    });
};
[
    [
        "EthanChiu6",
        "C",
        4789492,
        100.0
    ],
    [
        "sc.1101.rex",
        "A",
        4852542,
        100.0
    ],
    [
        "sc.1101.rex",
        "B",
        4852916,
        32.0
    ],
    [
        "Jasper7",
        "A",
        5121945,
        100.0
    ],
    [
        "Jasper7",
        "B",
        5122153,
        100.0
    ],
    [
        "RayYu",
        "A",
        5125237,
        100.0
    ],
    [
        "EthanChiu6",
        "A",
        5125395,
        100.0
    ],
    [
        "RayYu",
        "B",
        5125719,
        100.0
    ],
    [
        "EthanChiu6",
        "B",
        5125808,
        100.0
    ],
    [
        "Jasper7",
        "C",
        5129535,
        100.0
    ],
    [
        "RayYu",
        "C",
        5215629,
        100.0
    ],
    [
        "sc.1101.rex",
        "B",
        5931701,
        100.0
    ],
    [
        "sc.1101.rex",
        "C",
        6000439,
        40.0
    ],
    [
        "EthanChiu6",
        "D",
        6059774,
        33.0
    ],
    [
        "PureDevr",
        "A",
        6075001,
        100.0
    ],
    [
        "PureDevr",
        "B",
        6245039,
        100.0
    ],
    [
        "Kyle_Ho",
        "A",
        6421591,
        100.0
    ],
    [
        "Kyle_Ho",
        "K1",
        6422504,
        20.0
    ],
    [
        "Kyle_Ho",
        "K1",
        6423301,
        100.0
    ],
    [
        "sc.1101.rex",
        "K1",
        6423389,
        100.0
    ],
    [
        "jeff_wu0302",
        "A",
        6442806,
        100.0
    ],
    [
        "ericaaaaa",
        "A",
        6603314,
        100.0
    ],
    [
        "ericaaaaa",
        "B",
        6604963,
        32.0
    ],
    [
        "EthanChiu6",
        "D",
        6605554,
        100.0
    ],
    [
        "EthanChiu6",
        "K1",
        6686158,
        20.0
    ],
    [
        "EthanChiu6",
        "K1",
        6883106,
        100.0
    ],
    [
        "jeff_wu0302",
        "B",
        7788507,
        100.0
    ],
    [
        "jeff_wu0302",
        "J",
        7888511,
        20.0
    ],
    [
        "jeff_wu0302",
        "H1",
        8010815,
        10.0
    ],
    [
        "jeff_wu0302",
        "H1",
        8010829,
        30.0
    ],
    [
        "cam196883",
        "B",
        8016268,
        32.0
    ],
    [
        "cam196883",
        "A",
        8016365,
        100.0
    ],
    [
        "PureDevr",
        "C",
        8757071,
        40.0
    ],
    [
        "PureDevr",
        "C",
        8761587,
        100.0
    ],
    [
        "EthanChiu6",
        "I",
        8920379,
        20.0
    ]
]/* Programming contest management system
 * Copyright © 2012 Luca Wehrstedt <luca.wehrstedt@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

var HistoryStore = new function () {
    var self = this;

    self.init = function () {
        // List of score-change events divided by scope
        // _t contains all the tasks together, and _c does the same
        self.history_t = new Array();  // per task
        self.history_c = new Array();  // per contest
        self.history_g = new Array();  // global
    };

    self.request_update = function (callback) {
        $.ajax({
            url: Config.get_history_url(),
            dataType: "json",
            success: function (data) {
                self.perform_update(data, callback);
            },
            error: function () {
                console.error("Error while getting the history");
            }
        });
    };

    self.perform_update = function (data, callback) {
        var d = new Object();
        for (var u_id in DataStore.users) {
            d[u_id] = new Object();
            for (var t_id in DataStore.tasks) {
                d[u_id][t_id] = 0.0;
            }
        }

        self.history_t = new Array();
        self.history_c = new Array();
        self.history_g = new Array();

        for (var i in data) {
            var user = data[i][0];
            var task = data[i][1];
            var time = data[i][2];
            var score = data[i][3];

            if (d[user]) {
                d[user][task] = score;

                self.history_t.push([user, task, time, score]);

                var contest_id = DataStore.tasks[task]['contest'];
                var tmp_score = 0.0;
                for (var t_id in d[user]) {
                    if (DataStore.tasks[t_id]['contest'] == contest_id) {
                        tmp_score += d[user][t_id];
                    }
                }
                self.history_c.push([user, contest_id, time, tmp_score])

                var tmp_score = 0.0;
                for (var t_id in d[user]) {
                    tmp_score += d[user][t_id];
                }
                self.history_g.push([user, time, tmp_score]);
            }
        }

        callback();
    };

    self.get_score_history_for_task = function (user_id, task_id) {
        var result = new Array();

        for (var i in self.history_t) {
            var user = self.history_t[i][0];
            var task = self.history_t[i][1];
            var time = self.history_t[i][2];
            var score = self.history_t[i][3];
            if (user == user_id && task == task_id) {
                result.push([time, score, 0]);
            }
        }

        return result;
    };

    self.get_score_history_for_contest = function (user_id, contest_id) {
        var result = new Array();

        for (var i in self.history_c) {
            var user = self.history_c[i][0];
            var contest = self.history_c[i][1];
            var time = self.history_c[i][2];
            var score = self.history_c[i][3];
            if (user == user_id && contest == contest_id) {
                result.push([time, score, 0]);
            }
        }

        return result;
    };

    self.get_score_history = function (user_id) {
        var result = new Array();

        for (var i in self.history_g) {
            var user = self.history_g[i][0];
            var time = self.history_g[i][1];
            var score = self.history_g[i][2];
            if (user == user_id) {
                result.push([time, score, 0]);
            }
        }

        return result;
    };

    self.get_rank_history_for_task = function (user_id, task_id) {
        var d = new Object();
        for (var u_id in DataStore.users) {
            d[u_id] = 0.0;
        }
        var above = 0;
        var equal = DataStore.user_count;

        var result = new Array();

        // TODO consider together changes with the same time
        for (var i in self.history_t) {
            var user = self.history_t[i][0];
            var task = self.history_t[i][1];
            var time = self.history_t[i][2];
            var score = self.history_t[i][3];

            if (task == task_id) {
                if (user == user_id) {
                    d[user_id] = score;
                    var new_above = 0;
                    var new_equal = 0;
                    for (var s in d) {
                        if (d[s] > score) {
                            new_above += 1;
                        } else if (d[s] == score) {
                            new_equal += 1;
                        }
                    }
                    if (new_above != above || new_equal != equal) {
                        above = new_above;
                        equal = new_equal;
                        result.push([time, above+1, equal-1]);
                    }
                } else {
                    changed = false;
                    if (d[user] <= d[user_id] && score > d[user_id]) {
                        above += 1;
                        changed = true;
                    } else if (d[user] > d[user_id] && score <= d[user_id]) {
                        above -= 1;
                        changed = true;
                    }
                    if (d[user] == d[user_id]) {
                        equal -= 1;
                        changed = true;
                    } else if (score == d[user_id]) {
                        equal += 1;
                        changed = true;
                    }
                    if (changed) {
                        result.push([time, above+1, equal-1]);
                    }
                    d[user] = score;
                }
            }
        }

        return result;
    };

    self.get_rank_history_for_contest = function (user_id, contest_id) {
        var d = new Object();
        for (var u_id in DataStore.users) {
            d[u_id] = 0.0;
        }
        var above = 0;
        var equal = DataStore.user_count;

        var result = new Array();

        // TODO consider together changes with the same time
        for (var i in self.history_c) {
            var user = self.history_c[i][0];
            var contest = self.history_c[i][1];
            var time = self.history_c[i][2];
            var score = self.history_c[i][3];

            if (contest == contest_id) {
                if (user == user_id) {
                    d[user_id] = score;
                    var new_above = 0;
                    var new_equal = 0;
                    for (var s in d) {
                        if (d[s] > score) {
                            new_above += 1;
                        } else if (d[s] == score) {
                            new_equal += 1;
                        }
                    }
                    if (new_above != above || new_equal != equal) {
                        above = new_above;
                        equal = new_equal;
                        result.push([time, above+1, equal-1]);
                    }
                } else {
                    changed = false;
                    if (d[user] <= d[user_id] && score > d[user_id]) {
                        above += 1;
                        changed = true;
                    } else if (d[user] > d[user_id] && score <= d[user_id]) {
                        above -= 1;
                        changed = true;
                    }
                    if (d[user] == d[user_id]) {
                        equal -= 1;
                        changed = true;
                    } else if (score == d[user_id]) {
                        equal += 1;
                        changed = true;
                    }
                    if (changed) {
                        result.push([time, above+1, equal-1]);
                    }
                    d[user] = score;
                }
            }
        }

        return result;
    };

    self.get_rank_history = function (user_id) {
        var d = new Object();
        for (var u_id in DataStore.users) {
            d[u_id] = 0.0;
        }
        var above = 0;
        var equal = DataStore.user_count;

        var result = new Array();

        // TODO consider together changes with the same time
        for (var i in self.history_g) {
            var user = self.history_g[i][0];
            var time = self.history_g[i][1];
            var score = self.history_g[i][2];

            if (user == user_id) {
                d[user_id] = score;
                var new_above = 0;
                var new_equal = 0;
                for (var s in d) {
                    if (d[s] > score) {
                        new_above += 1;
                    } else if (d[s] == score) {
                        new_equal += 1;
                    }
                }
                if (new_above != above || new_equal != equal) {
                    above = new_above;
                    equal = new_equal;
                    result.push([time, above+1, equal-1]);
                }
            } else {
                changed = false;
                if (d[user] <= d[user_id] && score > d[user_id]) {
                    above += 1;
                    changed = true;
                } else if (d[user] > d[user_id] && score <= d[user_id]) {
                    above -= 1;
                    changed = true;
                }
                if (d[user] == d[user_id]) {
                    equal -= 1;
                    changed = true;
                } else if (score == d[user_id]) {
                    equal += 1;
                    changed = true;
                }
                if (changed) {
                    result.push([time, above+1, equal-1]);
                }
                d[user] = score;
            }
        }

        return result;
    };
};
<!DOCTYPE html>
<html>
    <head>
        <meta charset='utf-8'/>
        <link rel="shortcut icon" href="img/favicon.ico" />
        <link rel='stylesheet' href='Ranking.css'>
        <script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script type="text/javascript">
if (typeof jQuery == 'undefined') {
    document.write(unescape("%3Cscript type='text/javascript' src='lib/jquery.js'%3E%3C/script%3E"));
}
if (!("EventSource" in window)) {
    document.write(unescape("%3Cscript type='text/javascript' src='lib/eventsource.js'%3E%3C/script%3E"));
}
        </script>
        <script type="text/javascript" src="lib/raphael.js"></script>
        <!--[if lt IE 9]>
            <script type="text/javascript" src="lib/explorercanvas.js"></script>
        <![endif]-->
        <script type="text/javascript" src="Config.js"></script>
        <script type="text/javascript" src="DataStore.js"></script>
        <script type="text/javascript" src="HistoryStore.js"></script>
        <script type="text/javascript" src="Chart.js"></script>
        <script type="text/javascript" src="UserDetail.js"></script>
        <script type="text/javascript" src="TimeView.js"></script>
        <script type="text/javascript" src="TeamSearch.js"></script>
        <script type="text/javascript" src="Overview.js"></script>
        <script type="text/javascript" src="Scoreboard.js"></script>
        <script type="text/javascript" src="Ranking.js"></script>
        <title>Ranking</title>
    </head>
    <body>
        <div id="OuterFrame">
            <div id="LogoPanel">
                <img src="logo" alt="Logo" />
            </div>
            <div id="UpperPanel">
                <div id="ConnectionStatus_box">
                    <div id="ConnectionStatus_label">Status</div>
                    <div id="ConnectionStatus_text"></div>
                </div>
            </div>
            <div id="TimeView">
                <div id="TimeView_name"></div>
                <div id="TimeView_selector">
                    <div id="TimeView_time"></div><div id="TimeView_expand"><div class="caret"></div></div>
                    <div id="TimeView_selector_elapsed">Elapsed time</div>
                    <div id="TimeView_selector_remaining">Remaining time</div>
                    <div id="TimeView_selector_current">Current time</div>
                </div>
            </div>
            <div id="SidePanel">
                <div id="Overview"></div>
                <div style="color: #999; text-align: center; font-size: 12px; padding-top: 5px;">
                    Powered by <a style="color: #00A3DA; text-decoration: none;" href="https://cms-dev.github.io/" target="_blank">CMS</a>
                </div>
            </div>
            <div id="InnerFrame">
                <table id="Scoreboard">
                    <colgroup id="Scoreboard_cols"></colgroup>
                    <thead id="Scoreboard_head"></thead>
                    <tbody id="Scoreboard_body"></tbody>
                </table>
            </div>
        </div>
        <input id="TeamSearch_input" type="search" placeholder="Search Team"/>
        <div id="TeamSearch_bg">
            <div id="TeamSearch">
                <img id="TeamSearch_close" src="img/close.png" alt="Close"/>
                <div id="TeamSearch_body"></div>
            </div>
        </div>
        <div id="UserDetail_bg">
            <div id="UserDetail">
                <img id="UserDetail_close" src="img/close.png" alt="Close"/>
                <div id="UserDetail_header">
                    <div id="UserDetail_summary">
                        <img id="UserDetail_face" src="" alt="Face"/>
                        <div id="UserDetail_f_name"></div>
                        <div id="UserDetail_l_name"></div>
                        <div id="UserDetail_team"></div>
                        <img id="UserDetail_flag" src="" alt="Flag"/>
                    </div>
                    <div id="UserDetail_navigator">
                        <table>
                            <col class="name"/>
                            <col class="score"/>
                            <col class="rank"/>
                            <col class="show"/>
                            <thead>
                                <tr>
                                    <td></td>
                                    <td>Score</td>
                                    <td>Rank</td>
                                    <td></td>
                                </tr>
                            </thead>
                            <tbody id="UserDetail_scores">
                            </tbody>
                        </table>
                    </div>
                </div>
                <div id="UserDetail_title"></div>
                <div id="UserDetail_charts">
                    <canvas id="UserDetail_score_chart" width="920" height="250"></canvas>
                    <canvas id="UserDetail_rank_chart" width="920" height="250"></canvas>
                </div>
                <div id="UserDetail_submissions">
                </div>
            </div>
        </div>
    </body>
</html> 
PNG
/* Programming contest management system
 * Copyright © 2012 Luca Wehrstedt <luca.wehrstedt@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

var Overview = new function () {
    var self = this;

    self.PAD_T = 20;
    self.PAD_B = 10;
    self.PAD_L = 10;
    self.PAD_R = 10;

    self.init = function () {
        var $elem = $("#Overview");

        self.width = $elem.width();
        self.height = $elem.height();

        self.paper = Raphael($elem[0], self.width, self.height);

        self.create_score_chart();

        self.update_score_axis();
        self.update_rank_axis();


        $(window).resize(function () {
            self.width = $elem.width();
            self.height = $elem.height();

            self.paper.setSize(self.width, self.height);

            self.update_score_chart(0);

            self.update_score_axis();
            self.update_rank_axis();

            self.update_markers(0);
        });


        DataStore.user_update.add(function (key, old_data, data) {
            if (old_data["markers"]) {
                data["markers"] = old_data["markers"];
                delete old_data["markers"];
            }
            if (old_data["marker_c_anim"]) {
                data["marker_c_anim"] = old_data["marker_c_anim"];
                delete old_data["marker_c_anim"];
            }
            if (old_data["marker_u_anim"]) {
                data["marker_u_anim"] = old_data["marker_u_anim"];
                delete old_data["marker_u_anim"];
            }
            if ($.inArray(old_data, self.user_list) != -1) {
                self.user_list.splice($.inArray(old_data, self.user_list), 1, data);
            }
        });

        DataStore.score_events.add(self.score_handler);
        DataStore.rank_events.add(self.rank_handler);
        DataStore.select_events.add(self.select_handler);


        // HEADERS ("Score" and "Rank")
        self.paper.setStart();
        self.paper.text(4, 10, "Score").attr("text-anchor", "start");
        self.paper.text(self.width - 4, 10, "Rank").attr("text-anchor", "end");
        var set = self.paper.setFinish();
        set.attr({"font-size": "12px", "fill": "#000000", "stroke": "none", "font-family": "sans-serif", "opacity": 0});

        $elem.mouseenter(function () {
            set.animate({"opacity": 1}, 1000);
        });

        $elem.mouseleave(function () {
            set.animate({"opacity": 0}, 1000);
        });


        // Load initial data.
        $.each(DataStore.users, function (u_id, user) {
            if (user["selected"] > 0)
            {
                self.user_list.push(user);
            }
        });
        self.user_list.sort(self.compare_users);
        self.update_markers(0);
    };


    /** SCORE & RANK AXIS */

    self.update_score_axis = function () {
        var d = Raphael.format("M {1},{3} L {1},{7} M {0},{4} L {2},{4} M {0},{5} L {2},{5} M {0},{6} L {2},{6}",
                               self.PAD_L - 4,
                               self.PAD_L,
                               self.PAD_L + 4,
                               self.PAD_T,
                               self.PAD_T + (self.height - self.PAD_T - self.PAD_B) * 0.25,
                               self.PAD_T + (self.height - self.PAD_T - self.PAD_B) * 0.50,
                               self.PAD_T + (self.height - self.PAD_T - self.PAD_B) * 0.75,
                               self.height - self.PAD_B);

        if (self.score_axis) {
            self.score_axis.attr("path", d);
        } else {
            self.score_axis = self.paper.path(d).attr(
                {"fill": "none", "stroke": "#b8b8b8", "stroke-width": 3, "stroke-linecap": "round"});
        }
    };


    self.update_rank_axis = function () {
        var d = Raphael.format("M {1},{3} L {1},{4} M {0},{3} L {2},{3} M {0},{4} L {2},{4}",
                               self.width - self.PAD_R - 4,
                               self.width - self.PAD_R,
                               self.width - self.PAD_R + 4,
                               self.PAD_T,
                               self.height - self.PAD_B);

        var ranks = [
            { color: "#ffd700", ratio: 1/12 },
            { color: "#c0c0c0", ratio: 2/12 },
            { color: "#cd7f32", ratio: 3/12 },
            { color: "#000000", ratio: 6/12 }
        ];
        var stops = [];
        var base = 0;
        for (var i = 0; i < ranks.length; i++) {
            stops.push(ranks[i].color + ":" + (base + (ranks[i].ratio / 3)) * 100);
            stops.push(ranks[i].color + ":" + (base + (ranks[i].ratio / 3 * 2)) * 100);
            base += ranks[i].ratio;
        }
        stops = stops.join("-");

        if (self.rank_axis) {
            self.rank_axis.attr("path", d);
        } else {
            // Since raphael does not support gradients for stroke, we set the fill attr to it,
            // then move the value to stroke.
            self.rank_axis = self.paper.path(d).attr({
                "fill": "270-" + stops,
                "stroke-width": 3,
                "stroke-linecap": "round"
            });
            self.rank_axis.node.setAttribute("stroke", self.rank_axis.node.getAttribute("fill"));
            self.rank_axis.node.setAttribute("fill", "none");
        }
    };


    /** SCORE CHART */

    self.SCORE_STEPS = 15;

    // scores[0] contains the number of users with a score of zero
    // scores[i] (with i in [1..SCORE_STEPS]) contains the number of users with
    //     a score in the half-open interval [i * (max_score / SCORE_STEPS),
    //     (i+1) * (max_score / SCORE_STEPS)). for i == 0 the interval is open
    // scores[SCORE_STEPS+1] contins the number of user with the max_score
    // see also self.get_score_class()
    self.scores = new Array();

    for (var i = 0; i <= self.SCORE_STEPS + 1; i += 1) {
        self.scores.push(0);
    }


    self.make_path_for_score_chart = function () {
        // For each element of self.scores, we convert the number it contains
        // to a distance from the score axis and then create a smooth path that
        // passes on all those points.
        // To convert the number of users to a distance we use the following
        // formula (a parabola, open down):  d(x) = a * x^2 + b * x + c
        // with a, b and c parameters chosen such that:
        // - d(0) = 0;        - d'(0) = 3/2;
        // - d(max_users) = 3/4 * width (excluding padding);

        var max_users = DataStore.user_count;
        var a = (3/4 * (self.width - self.PAD_R - self.PAD_L) - 3/2 * max_users) / (max_users * max_users);
        var b = 3/2;
        var c = 0;

        var s_path = "";
        for (var i = 0; i <= self.SCORE_STEPS + 1; i += 1) {
            var x = self.PAD_L + a * self.scores[i] * self.scores[i] + b * self.scores[i] + c;
            var y = self.height - self.PAD_B - i * (self.height - self.PAD_T - self.PAD_B) / (self.SCORE_STEPS + 1);
            if (i == 0) {
                s_path += Raphael.format("M {0},{1} R", x, y);
            } else {
                s_path += Raphael.format(" {0},{1}", x, y);
            }
        }

        return s_path;
    };


    self.recompute = function () {
        // Recompute self.scores
        for (var i = 0; i <= self.SCORE_STEPS + 1; i += 1) {
            self.scores[i] = 0;
        }

        var users = DataStore.users;
        var max_score = DataStore.global_max_score;

        for (var u_id in users) {
            self.scores[self.get_score_class(users[u_id]["global"], max_score)] += 1;
        }
    };


    self.create_score_chart = function () {
        self.recompute();
        var s_path = self.make_path_for_score_chart();
        self.score_line = self.paper.path(s_path).attr({"fill": "none", "stroke": "#cccccc", "stroke-width": 2, "stroke-linecap": "round"});
        s_path += Raphael.format(" L {0},{1} {0},{2} Z", self.PAD_L, self.PAD_T, self.height - self.PAD_B);
        self.score_back = self.paper.path(s_path).attr({"fill": "0-#E4E4E4-#DADADB", "stroke": "none"});
        self.score_back.toBack();
    };


    self.update_score_chart = function (t) {
        var s_path = self.make_path_for_score_chart();
        self.score_line.animate({'path': s_path}, t);
        s_path += Raphael.format(" L {0},{1} {0},{2} Z", self.PAD_L, self.PAD_T, self.height - self.PAD_B);
        self.score_back.animate({'path': s_path}, t);
    };


    self.get_score_class = function (score, max_score) {
        if (score <= 0) {
            return 0;
        } else if (score >= max_score) {
            return self.SCORE_STEPS + 1;
        } else {
            return parseInt(score / max_score * self.SCORE_STEPS) + 1;
        }
    };


    /** MARKERS */


    // We keep a sorted list of user that represent the current order of the
    // selected users in the overview. In particular we sort using these keys:
    // - the global score
    // - the last name
    // - the first name
    // - the key
    self.user_list = new Array();


    // Compare two users. Returns -1 if "a < b" or +1 if "a >= b"
    // (where a < b means that a shoud go above b in the overview)
    self.compare_users = function (a, b) {
        if ((a["global"] > b["global"]) || ((a["global"] == b["global"]) &&
           ((a["l_name"] < b["l_name"]) || ((a["l_name"] == b["l_name"]) &&
           ((a["f_name"] < b["f_name"]) || ((a["f_name"] == b["f_name"]) &&
           (a["key"] <= b["key"]))))))) {
            return -1;
        } else {
            return +1;
        }
    };

    self.MARKER_PADDING = 2;
    self.MARKER_RADIUS = 2.5;
    self.MARKER_LABEL_WIDTH = 50;
    self.MARKER_LABEL_HEIGHT = 20;
    self.MARKER_ARROW_WIDTH = 20;
    self.MARKER_STROKE_WIDTH = 2;

    self.make_path_for_marker = function (s_h, u_h, r_h) {
        // The path is composed of a label (whose vertical center is at u_h,
        // self.MARKER_LABEL_WIDTH wide and self.MARKER_LABEL_HEIGHT high),
        // made of two horizontal (H) lines (for top and bottom), delimited on
        // the right by two straight lines (L) forming an arrow (which is
        // self.MARKER_ARROW_WIDTH wide), with its center at an height of r_h.
        // On the left two cubic bezier curves (C) start tangentially from the
        // label and end, still tangentially, on an elliptic arc (A), with its
        // center at an height of s_h and a radius of self.MARKER_RADIUS.
        // The path starts just above the arc, with the first cubic bezier.

        // TODO Most of these values are constants, no need to recompute
        // everything again every time.

        return Raphael.format("M {0},{5} C {1},{5} {1},{6} {2},{6} H {3} L {4},{7} {3},{8} H {2} C {1},{8} {1},{9} {0},{9} A {10},{10} 0 0,1 {0},{5} Z",
                              self.PAD_L,
                              (self.PAD_L + self.width - self.PAD_R - self.MARKER_ARROW_WIDTH - self.MARKER_LABEL_WIDTH) / 2,
                              self.width - self.PAD_R - self.MARKER_ARROW_WIDTH - self.MARKER_LABEL_WIDTH,
                              self.width - self.PAD_R - self.MARKER_ARROW_WIDTH,
                              self.width - self.PAD_R,
                              s_h - self.MARKER_RADIUS,
                              u_h - (self.MARKER_LABEL_HEIGHT - self.MARKER_STROKE_WIDTH) / 2,
                              r_h,
                              u_h + (self.MARKER_LABEL_HEIGHT - self.MARKER_STROKE_WIDTH) / 2,
                              s_h + self.MARKER_RADIUS,
                              self.MARKER_RADIUS);
    };


    self.create_marker = function (user, s_h, u_h, r_h, t) {
        var d = self.make_path_for_marker(s_h, u_h, r_h);

        // Map the color_index given by DataStore to the actual color
        // (FIXME This almost duplicates some code in Ranking.css...)
        switch (user["selected"]) {
            case 1:  // Blue
                var color_a = "#729fcf";
                var color_b = "#3465a4";
                break;
            case 2:  // Butter
                var color_a = "#fce94f";
                var color_b = "#edd400";
                break;
            case 3:  // Red
                var color_a = "#ef2929";
                var color_b = "#cc0000";
                break;
            case 4:  // Chameleon
                var color_a = "#8ae234";
                var color_b = "#73d216";
                break;
            case 5:  // Orange
                var color_a = "#fcaf3e";
                var color_b = "#f57900";
                break;
            case 6:  // Plum
                var color_a = "#ad7fa8";
                var color_b = "#75507b";
                break;
            case 7:  // Aluminium
                var color_a = "#babdb6";
                var color_b = "#888a85";
                break;
            case 8:  // Chocolate
                var color_a = "#e9b96e";
                var color_b = "#c17d11";
                break;
        }

        self.paper.setStart();
        self.paper.path(d).attr({
            "fill": color_b,
            "stroke": color_a,
            "stroke-width": self.MARKER_STROKE_WIDTH,
            "stroke-linejoin": "round"});
        // Place the text inside the label, with a padding-right equal to its
        // padding-top and padding-bottom.
        var t_x = self.width - self.PAD_R - self.MARKER_ARROW_WIDTH - (self.MARKER_LABEL_HEIGHT - 12) / 2;
        self.paper.text(t_x, u_h, self.transform_key(user)).attr({
            "fill": "#ffffff",
            "stroke": "none",
            "font-family": "sans-serif",
            "font-size": "12px",
            "text-anchor": "end"});
        var set = self.paper.setFinish();
        set.attr({"cursor": "pointer",
                  "opacity": 0});

        set.click(function () {
            Scoreboard.scroll_into_view(user["key"]);
        });

        user["markers"] = set;

        user["marker_c_anim"] = Raphael.animation({"opacity": 1}, t, function () {
            delete user["marker_c_anim"];
        });
        set.animate(user["marker_c_anim"]);
    };

    self.transform_key = function(user) {
      var s = user['f_name'] + ' ' + user['l_name'];
      var sl = s.split(' ');
      var out = '';
      for (var i = 0; i < sl.length; i++) {
          if (sl[i].length > 0) {
              out += sl[i][0];
          }
      }
      if (user["team"] != null && user["team"] != undefined) {
          return user['team'] + '-' + out;
      } else {
          return out;
      }
    };


    self.update_marker = function (user, s_h, u_h, r_h, t) {
        var d = self.make_path_for_marker(s_h, u_h, r_h);

        // If the duration of the animation is 0 or if the element has just
        // been created (i.e. its creation animation hasn't finished yet) then
        // just set the new path and position. Else, animate them.
        if (t && !user["marker_c_anim"]) {
            user["markers"].stop();
            user["marker_u_anim"] = Raphael.animation({"path": d, "y": u_h}, t, function () {
                delete user["marker_u_anim"];
            });
            user["markers"].animate(user["marker_u_anim"]);
        } else {
            user["markers"].attr({"path": d, "y": u_h});
        }
    };


    self.delete_marker = function (user, t) {
        var markers = user["markers"];
        delete user["markers"];

        // If an update animation is running, we stop and delete it
        if (user["marker_u_anim"]) {
            markers.stop();
            delete user["marker_u_anim"];
        }

        var anim = Raphael.animation({"opacity": 0}, t, function () {
            markers.remove();
        });
        markers.animate(anim);

        self.user_list.splice($.inArray(user, self.user_list), 1);
        self.update_markers(t);
    };


    self.get_score_height = function (score, max_score) {
        if (max_score <= 0) {
            return self.height - self.PAD_B;
        }
        return self.height - self.PAD_B - score / max_score * (self.height - self.PAD_T - self.PAD_B);
    };


    self.get_rank_height = function (rank, max_rank) {
        if (max_rank <= 1) {
            return self.PAD_T;
        }
        return self.PAD_T + (rank - 1) / (max_rank - 1) * (self.height - self.PAD_T - self.PAD_B);
    };


    self.merge_clusters = function (a, b) {
        // See the next function to understand the purpose of this function
        var middle = (a.n * (a.b + a.e) / 2 + b.n * (b.b + b.e) / 2) / (a.n + b.n);
        a.list = a.list.concat(b.list);
        a.n += b.n;
        a.b = middle - (a.n * self.MARKER_LABEL_HEIGHT + (a.n - 1) * self.MARKER_PADDING) / 2;
        a.e = a.b + a.n * self.MARKER_LABEL_HEIGHT + (a.n - 1) * self.MARKER_PADDING;
    };


    self.update_markers = function (t) {
        // Use them as shortcut
        var h = self.MARKER_LABEL_HEIGHT;
        var p = self.MARKER_PADDING;

        // We iterate over all selected users (in top-to-bottom order). For
        // each of them we create a cluster which, initally, contains just that
        // user. Then, if the cluster overlaps with another, we merge them and
        // increase its size so that its element don't overlap anymore. We
        // repeat this process unit no two clusters overlap, and then proceed
        // to the next user. We also take care that no cluster is outside the
        // visible area, either above or below.

        // The list of clusters and its size (n == cs.length)
        var cs = new Array();
        var n = 0;

        for (var i in self.user_list) {
            var user = self.user_list[i];
            var r_height = self.get_rank_height(user["rank"], DataStore.user_count);

            // 'b' (for begin) is the y coordinate of the top of the cluster
            // 'e' (for end) is the y coordinate of the bottom of the cluster
            // 'n' is the number of items it contains (c.n == c.list.length)
            cs.push({'b': r_height - h/2, 'e': r_height + h/2, 'list': [user], 'n': 1});
            n += 1;

            // Check if it overlaps with the one above it
            while (n > 1 && cs[n-2].e + p > cs[n-1].b) {
                self.merge_clusters(cs[n-2], cs[n-1]);
                cs.pop();
                n -= 1;
            }

            // Check if it overflows at the top of the visible area
            if (cs[n-1].b < self.PAD_T - h/2) {
                cs[n-1].e += (self.PAD_T - h/2) - cs[n-1].b;
                cs[n-1].b = self.PAD_T - h/2;
            }
        }

        // Check if it overflows at the bottom of the visible area
        while (n > 0 && cs[n-1].e > self.height - self.PAD_B + h/2) {
            cs[n-1].b += (self.height - self.PAD_B + h/2) - cs[n-1].e;
            cs[n-1].e = self.height - self.PAD_B + h/2;

            // Check if it overlaps with the one above it
            if (n > 1 && cs[n-2].e + p > cs[n-1].b) {
                self.merge_clusters(cs[n-2], cs[n-1]);
                cs.pop();
                n -= 1;
            }
        }

        // If it overflows again at the top then there's simply not enough
        // space to hold them all. Compress them.
        if (n > 0 && cs[0].b < self.PAD_T - h/2) {
            cs[0].b = self.PAD_T - h/2;
        }

        // Proceed with the actual drawing
        for (var i in cs) {
            var c = cs[i];
            var begin = c.b;
            var step = (c.e - begin - h) / (c.n - 1);  // NaN if c.n == 1

            for (var j in c.list) {
                var user = c.list[j];

                var s_height = self.get_score_height(user["global"], DataStore.global_max_score);
                var r_height = self.get_rank_height(user["rank"], DataStore.user_count);

                if (user["markers"]) {
                    // Update the existing marker
                    self.update_marker(user, s_height, begin + h/2, r_height, t);
                } else {
                    // Create a new marker
                    self.create_marker(user, s_height, begin + h/2, r_height, t);
                }

                begin += step;  // begin is NaN if step is NaN: no problem
                                // because if c.n == 1 begin won't be used again
            }
        }
    };


    self.score_handler = function (u_id, user, t_id, task, delta) {
        var new_score = user["global"];
        var old_score = new_score - delta;
        var max_score = DataStore.global_max_score;

        self.scores[self.get_score_class(old_score, max_score)] -= 1;
        self.scores[self.get_score_class(new_score, max_score)] += 1;

        self.update_score_chart(1000);

        if (user["selected"] > 0) {
            self.user_list.sort(self.compare_users);
            self.update_markers(1000);
        }
    };


    self.rank_handler = function (u_id, user, delta) {
        if (user["selected"] > 0) {
            self.update_markers(1000);
        }
    };


    self.select_handler = function (u_id, color) {
        var user = DataStore.users[u_id];
        if (color > 0) {
            self.user_list.push(user);
            self.user_list.sort(self.compare_users);
            self.update_markers(1000);
        } else {
            self.delete_marker(DataStore.users[u_id], 1000);
        }
    };

    /* TODO: When users get added/removed the total user count changes and all
       rank "markers" need to be adjusted!
     */
};
body {
    /* FIXME: I'd suggest putting a 0.75em font-size */
    font: 1em/1.5em sans-serif;

    color: black;

    background-color: #F6F6F6;
    background-image: -webkit-linear-gradient(#FFFFFF, #EDEDED);
    background-image:    -moz-linear-gradient(#FFFFFF, #EDEDED);
    background-image:      -o-linear-gradient(#FFFFFF, #EDEDED);
    background-image:         linear-gradient(#FFFFFF, #EDEDED);
    background-attachment: fixed;

    margin: 0;
}

/* TODO: the following two might be omitted */

td {
    padding: 0;
}

a {
    outline: none;
}

abbr {
    border-bottom: 1px dotted black;
}

/******************************************************************************\
|                                                                              |
|                                   Page layout                                |
|                                   -----------                                |
\******************************************************************************/


#LogoPanel {
    position: absolute;
    top: 24px;
    left: 24px;
    width: 200px;
}

#UpperPanel {
    position: absolute;
    top: 0;
    left: 248px;
    right: 0;
    height: 3em;
    border-width: 0 0 2px 2px;
    border-style: solid;
    border-color: #FAFAFA;
    border-radius: 0 0 0 10px;
    background-color: #EAEAEC;
    box-shadow: 0 0 2px 0 gray;
    z-index: 100;
}

#SidePanel {
    position: absolute;
    left: 0;
    top: 208px;
    bottom: 30px;
    width: 220px;
    border-width: 2px 2px 2px 0;
    border-style: solid;
    border-color: #FAFAFA;
    border-radius: 0 10px 10px 0;
    background-color: #EAEAEC;
    box-shadow: 0 0 2px 0 gray;
    z-index: 8;
    padding: 0;
}

#InnerFrame {
    position: absolute;
    top: 3em;
    left: 220px;
    right: 0;
    bottom: 0;
    margin: 2px 0 0 2px;
    padding: 0 3em;
    overflow-y: scroll;
}


/******************************************************************************\
|                                                                              |
|                                    Time View                                 |
|                                    ---------                                 |
\******************************************************************************/


#TimeView {
    position: absolute;
    top: 208px;
    left: 0;
    width: 220px;
    z-index: 10;
    text-align: center;
}

#TimeView_selector {
    display: inline-block;
    height: 28px;
    padding: 0;
    z-index: 10;
    margin: 4px;
    overflow: hidden;
    -webkit-user-select: none;
       -moz-user-select: none;
        -ms-user-select: none;
         -o-user-select: none;
            user-select: none;
}

/* #TimeView:not(.post_cont) #TimeView_selector:hover */
#TimeView.pre_cont #TimeView_selector:hover,
#TimeView.cont #TimeView_selector:hover,
#TimeView_selector.open {
    margin: 2px;
    background-color: #EAEAEC;
    border: 2px solid #FAFAFA;
    border-radius: 4px;
    box-shadow: 0 0 2px 0 gray;
}

#TimeView_selector.open {
    height: auto;
}

#TimeView_time {
    display: inline-block;
    vertical-align: top;
    text-align: center;
    line-height: 28px;
    font-size: 24px;
    margin: 0 2px 0 16px;
}

#TimeView_expand {
    display: inline-block;
    position: relative;
    width: 8px;
    height: 28px;
    vertical-align: top;
    cursor: pointer;
    margin: 0 4px 0 2px;
}

#TimeView_selector .caret {
    position: absolute;
    top: 12px;
    width: 0;
    height: 0;
    vertical-align: middle;
    border-top: 6px solid #AAAAAA;
    border-right: 4px solid transparent;
    border-left: 4px solid transparent;
    border-bottom: 0;
}

#TimeView_selector:hover .caret {
    border-top-color: #000000;
}

#TimeView_selector.open .caret {
    top: 10px;
    border-top: 0;
    border-right: 4px solid transparent;
    border-left: 4px solid transparent;
    border-bottom: 6px solid #000000;
}

#TimeView.post_cont #TimeView_time {
    margin-right: 16px;
}

#TimeView.post_cont #TimeView_expand {
    display: none;
}

#TimeView_selector_elapsed,
#TimeView_selector_remaining,
#TimeView_selector_current {
    padding: 2px 4px;
    font-size: 0.875em;
    line-height: 1.4em;
    color: #444444;
    cursor: pointer;
}

#TimeView.pre_cont #TimeView_selector_elapsed,
#TimeView.post_cont #TimeView_selector_elapsed,
#TimeView.post_cont #TimeView_selector_remaining {
    display: none;
}

#TimeView.elapsed #TimeView_selector_elapsed,
#TimeView.remaining #TimeView_selector_remaining,
#TimeView.current #TimeView_selector_current {
    background-color: #F2F2F3;
    color: #000000;
}

#TimeView_selector_elapsed:hover,
#TimeView_selector_remaining:hover,
#TimeView_selector_current:hover {
    background-color: #FAFAFA !important;
    color: #000000;
}

#TimeView + #SidePanel {
    top: 256px;
}

#TimeView.pre_cont + #SidePanel,
#TimeView.cont + #SidePanel {
    top: 280px;
}


/******************************************************************************\
|                                                                              |
|                                   Right panel                                |
|                                   -----------                                |
\******************************************************************************/


#Overview {
    position: relative;
    height: 100%;
    width: 100%;
}


/******************************************************************************\
|                                                                              |
|                                   Team search                                |
|                                   -----------                                |
\******************************************************************************/


#TeamSearch_input {
    position: absolute;
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    top: 0;
    left: 250px;
    height: 1.5em;
    margin: 0.5em;
    border: 0;
    padding: 0.25em;
    z-index: 401;
    border-radius: 0.5em;
    /* Needed to override WebKit's default font size for inputs */
    font: inherit;
    background-color: #FFFFFF;
    outline: 0;
}

#TeamSearch_bg {
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 400;
    background-color: rgba(0,0,0,0.5);
    /* the following two lines are for IE */
    -ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr=#80000000, endColorstr=#80000000)";
    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#80000000, endColorstr=#80000000);
}

#TeamSearch_bg.open {
    display: block;
}

#TeamSearch {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 940px;
    margin: 64px auto 48px;
    border-radius: 12px;
    background-color: white;
}

#TeamSearch_close {
    position: absolute;
    top: -10px;
    right: -10px;
    width: 24px;
    height: 24px;
    cursor: pointer;
}

#TeamSearch_body {
    position: absolute;
    top: 14px; /* 20px - 0.5em at a 12px font-size */
    top: -webkit-calc(20px - 0.5em);
    top:    -moz-calc(20px - 0.5em);
    top:         calc(20px - 0.5em);
    left: 10px;
    right: 10px;
    bottom: 14px; /* 20px - 0.5em at a 12px font-size */
    bottom: -webkit-calc(20px - 0.5em);
    bottom:    -moz-calc(20px - 0.5em);
    bottom:         calc(20px - 0.5em);
    overflow-y: auto;
}

#TeamSearch_body div.item {
    float: left;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    width: 25%;
    height: 3em;
    padding: 0;
    border: 0 solid white;
    border-width: 0.5em 10px;
    background-color: #DDDDDD;

    -webkit-user-select: none;
     -khtml-user-select: none;
       -moz-user-select: none;
         -o-user-select: none;
            user-select: none;
}

#TeamSearch_body div.item.hidden {
    display: none;
}

#TeamSearch_body div.item label {
    display: block;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    width: 100%;
    height: 100%;
    padding: 0.25em 5px;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
}

#TeamSearch_body div.item input {
    margin: auto 1px auto 0;
    vertical-align: middle;
}

#TeamSearch_body div.item img {
    display: inline-block;
    max-height: 20px;
    vertical-align: top;
    margin-top: -1px; /* (1.5em - 20px) / 2 at a 12px font-size */
    margin-top: -webkit-calc(0.75em - 10px);
    margin-top:    -moz-calc(0.75em - 10px);
    margin-top:         calc(0.75em - 10px);
}


/******************************************************************************\
|                                                                              |
|                                   Scoreboard                                 |
|                                   ----------                                 |
\******************************************************************************/


#Scoreboard {
    width: 100%;
    table-layout: fixed;
    margin: 3em 0;
}

#Scoreboard_cols col.sel {
    width: 2em;
}

#Scoreboard_cols col.rank {
    width: 48px;
}

#Scoreboard_cols col.team {
    /* This is the minimum width needed to contain a flag */
    width: 42px;
    /* These rules set the horizontal padding to the same value as the
       vertical one (in presence of a flag with a 2:1 ratio) */
    width: -webkit-calc(2em + 20px);
    width:    -moz-calc(2em + 20px);
    width:         calc(2em + 20px);
}

#Scoreboard_head tr {
    height: 2.5em;
}

#Scoreboard_body tr {
    height: 2em;
}

#Scoreboard_head tr th {
    background-color: #ECECEF;
    border: 1px #D0D0D2 solid;
    border-radius: 4px;
    box-shadow: 0 0 2px 0 #D2D2D4 inset;
    height: 24px;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
}

#Scoreboard_body tr td.team {
    vertical-align: middle;
}

#Scoreboard_body tr td.team img {
    display: block;
    max-width: 40px;
    max-height: 20px;
    margin: 0 auto;
    box-shadow: 0 0 2px 0 gray;
}

#Scoreboard_head tr th,
#Scoreboard_body tr td {
    text-align: center;
}

#Scoreboard_body tr td.f_name,
#Scoreboard_body tr td.l_name {
    text-align: left;
    padding: 0 0.5em;
    cursor: pointer;
}

#Scoreboard_head tr th.sel {
    background-image: url('img/tick_black.png');
    background-repeat: no-repeat;
    background-position: center;
}

#Scoreboard_head tr th.score {
    cursor: pointer;
}

#Scoreboard_body tr:hover td.f_name,
#Scoreboard_body tr:hover td.l_name,
#Scoreboard_body tr:hover td.team {
    background-color: rgba(200,200,200,0.35);
    border-radius: 5px;
}

#Scoreboard_body tr.selected td.f_name,
#Scoreboard_body tr.selected td.l_name {
    font-weight: bold;
}

/* What follows is the CSS needed to manage the "checkboxes" in the Scoreboard,
   used to select users. We're simulating checkboxes using table cells, so we
   have to define their appearence in "normal" status as well as during user
   interaction. We did this so we can be more flexible on the style: we need
   to be able to set the background color of the checkbox and to make them a
   little bigger so that the color can be seen better.

   We use eight colors, taken from the Tango Palette:
   http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines#Color_Palette
 */

#Scoreboard_body tr td.sel {
    background: url('img/tick_black.png') no-repeat center transparent;
    opacity: 0;
    -webkit-user-select: none;
       -moz-user-select: none;
        -ms-user-select: none;
         -o-user-select: none;
            user-select: none;
}

#Scoreboard_body tr td.sel:hover {
    opacity: 0.3;
}

#Scoreboard_body tr td.sel:active {
    opacity: 0.5;
}

#Scoreboard_body tr.selected td.sel {
    background: url('img/tick_white.png') no-repeat center transparent;
    border: 1px solid rgba(0,0,0,0.2);
    border-radius: 4px;
    opacity: 1;
}

/* Color 1: Blue */

#Scoreboard_body tr.color1 td.sel {
    background-color: rgb(52,101,164);
}

#Scoreboard_body tr.color1 td.sel:hover {
    background-color: rgb(32,74,135);
}

#Scoreboard_body tr.color1 td.sel:active {
    background-color: rgb(26,59,108);
}

/* Color 2: Butter */

#Scoreboard_body tr.color2 td.sel {
    background-color: rgb(237,212,0);
}

#Scoreboard_body tr.color2 td.sel:hover {
    background-color: rgb(196,160,0);
}

#Scoreboard_body tr.color2 td.sel:active {
    background-color: rgb(157,128,0);
}

/* Color 3: Red */

#Scoreboard_body tr.color3 td.sel {
    background-color: rgb(204,0,0);
}

#Scoreboard_body tr.color3 td.sel:hover {
    background-color: rgb(164,0,0);
}

#Scoreboard_body tr.color3 td.sel:active {
    background-color: rgb(131,0,0);
}

/* Color 4: Chameleon */

#Scoreboard_body tr.color4 td.sel {
    background-color: rgb(115,210,22);
}

#Scoreboard_body tr.color4 td.sel:hover {
    background-color: rgb(78,154,6);
}

#Scoreboard_body tr.color4 td.sel:active {
    background-color: rgb(62,123,5);
}

/* Color 5: Orange */

#Scoreboard_body tr.color5 td.sel {
    background-color: rgb(245,121,0);
}

#Scoreboard_body tr.color5 td.sel:hover {
    background-color: rgb(206,92,0);
}

#Scoreboard_body tr.color5 td.sel:active {
    background-color: rgb(165,74,0);
}

/* Color 6: Plum */

#Scoreboard_body tr.color6 td.sel {
    background-color: rgb(117,80,123);
}

#Scoreboard_body tr.color6 td.sel:hover {
    background-color: rgb(92,53,102);
}

#Scoreboard_body tr.color6 td.sel:active {
    background-color: rgb(74,42,82);
}

/* Color 7: Aluminium */

#Scoreboard_body tr.color7 td.sel {
    background-color: rgb(136,138,133);
}

#Scoreboard_body tr.color7 td.sel:hover {
    background-color: rgb(85,87,83);
}

#Scoreboard_body tr.color7 td.sel:active {
    background-color: rgb(68,70,66);
}

/* Color 8: Chocolate */

#Scoreboard_body tr.color8 td.sel {
    background-color: rgb(193,125,17);
}

#Scoreboard_body tr.color8 td.sel:hover {
    background-color: rgb(143,89,2);
}

#Scoreboard_body tr.color8 td.sel:active {
    background-color: rgb(114,71,2);
}

/* This animation stuff is quite huge: every brosers implements it using its
   own prefix and we have to handle them all. In particular: for each animation
   we have to set three properties on a specific selector and we have to define
   a set of keyframes. We use the unprefixed rules and the following prefixes:
    -webkit-...  -moz-...  -o-...

   In addition, we have to cover some particular cases. A row that's being
   animated can seleted or unselected. Thus, we have the following cases:
    ("selected_")? "score_" ("up"|"down")

   Just to give some numbers: we have 16 sets of keyframes in total.
 */

#Scoreboard_body tr.score_up td.rank {
    border-radius: 5px;
    -webkit-animation-duration: 5s;
       -moz-animation-duration: 5s;
         -o-animation-duration: 5s;
            animation-duration: 5s;
    -webkit-animation-name: score_up;
       -moz-animation-name: score_up;
         -o-animation-name: score_up;
            animation-name: score_up;
    -webkit-animation-timing-function: ease-in;
       -moz-animation-timing-function: ease-in;
         -o-animation-timing-function: ease-in;
            animation-timing-function: ease-in;
}

#Scoreboard_body tr.score_down td.rank {
    border-radius: 5px;
    -webkit-animation-duration: 5s;
       -moz-animation-duration: 5s;
         -o-animation-duration: 5s;
            animation-duration: 5s;
    -webkit-animation-name: score_down;
       -moz-animation-name: score_down;
         -o-animation-name: score_down;
            animation-name: score_down;
    -webkit-animation-timing-function: ease-in;
       -moz-animation-timing-function: ease-in;
         -o-animation-timing-function: ease-in;
            animation-timing-function: ease-in;
}

@-webkit-keyframes score_up {
    from {background-color: rgba(138,226,52,0);}
    10% {background-color: rgba(138,226,52,0.6);}
    to {background-color: rgba(138,226,52,0);}
}

@-moz-keyframes score_up {
    from {background-color: rgba(138,226,52,0);}
    10% {background-color: rgba(138,226,52,0.6);}
    to {background-color: rgba(138,226,52,0);}
}

@-o-keyframes score_up {
    from {background-color: rgba(138,226,52,0);}
    10% {background-color: rgba(138,226,52,0.6);}
    to {background-color: rgba(138,226,52,0);}
}

@keyframes score_up {
    from {background-color: rgba(138,226,52,0);}
    10% {background-color: rgba(138,226,52,0.6);}
    to {background-color: rgba(138,226,52,0);}
}

@-webkit-keyframes score_down {
    from {background-color: rgba(239,41,41,0);}
    10% {background-color: rgba(239,41,41,0.6);}
    to {background-color: rgba(239,41,41,0);}
}

@-moz-keyframes score_down {
    from {background-color: rgba(239,41,41,0);}
    10% {background-color: rgba(239,41,41,0.6);}
    to {background-color: rgba(239,41,41,0);}
}

@-o-keyframes score_down {
    from {background-color: rgba(239,41,41,0);}
    10% {background-color: rgba(239,41,41,0.6);}
    to {background-color: rgba(239,41,41,0);}
}

@keyframes score_down {
    from {background-color: rgba(239,41,41,0);}
    10% {background-color: rgba(239,41,41,0.6);}
    to {background-color: rgba(239,41,41,0);}
}

#Scoreboard_body tr.selected.score_up td.rank {
    border-radius: 5px;
    -webkit-animation-duration: 10s;
       -moz-animation-duration: 10s;
         -o-animation-duration: 10s;
            animation-duration: 10s;
    -webkit-animation-name: selected_score_up;
       -moz-animation-name: selected_score_up;
         -o-animation-name: selected_score_up;
            animation-name: selected_score_up;
    -webkit-animation-timing-function: ease-in;
       -moz-animation-timing-function: ease-in;
         -o-animation-timing-function: ease-in;
            animation-timing-function: ease-in;
}

#Scoreboard_body tr.selected.score_down td.rank {
    border-radius: 5px;
    -webkit-animation-duration: 10s;
       -moz-animation-duration: 10s;
         -o-animation-duration: 10s;
            animation-duration: 10s;
    -webkit-animation-name: selected_score_down;
       -moz-animation-name: selected_score_down;
         -o-animation-name: selected_score_down;
            animation-name: selected_score_down;
    -webkit-animation-timing-function: ease-in;
       -moz-animation-timing-function: ease-in;
         -o-animation-timing-function: ease-in;
            animation-timing-function: ease-in;
}

@-webkit-keyframes selected_score_up {
    from {background-color: rgba(138,226,52,0);}
    5% {background-color: rgba(138,226,52,1);}
    to {background-color: rgba(138,226,52,0);}
}

@-moz-keyframes selected_score_up {
    from {background-color: rgba(138,226,52,0);}
    5% {background-color: rgba(138,226,52,1);}
    to {background-color: rgba(138,226,52,0);}
}

@-o-keyframes selected_score_up {
    from {background-color: rgba(138,226,52,0);}
    5% {background-color: rgba(138,226,52,1);}
    to {background-color: rgba(138,226,52,0);}
}

@keyframes selected_score_up {
    from {background-color: rgba(138,226,52,0);}
    5% {background-color: rgba(138,226,52,1);}
    to {background-color: rgba(138,226,52,0);}
}

@-webkit-keyframes selected_score_down {
    from {background-color: rgba(239,41,41,0);}
    5% {background-color: rgba(239,41,41,1);}
    to {background-color: rgba(239,41,41,0);}
}

@-moz-keyframes selected_score_down {
    from {background-color: rgba(239,41,41,0);}
    5% {background-color: rgba(239,41,41,1);}
    to {background-color: rgba(239,41,41,0);}
}

@-o-keyframes selected_score_down {
    from {background-color: rgba(239,41,41,0);}
    5% {background-color: rgba(239,41,41,1);}
    to {background-color: rgba(239,41,41,0);}
}

@keyframes selected_score_down {
    from {background-color: rgba(239,41,41,0);}
    5% {background-color: rgba(239,41,41,1);}
    to {background-color: rgba(239,41,41,0);}
}

/*
   The animation stuff ends here.
 */

#Scoreboard_body tr td.score {
    opacity: 0.75;
    border-radius: 5px;
}

#Scoreboard_body tr td.score.sort_key {
    border: 1px solid #777777;
    box-shadow: 0 0 1px white inset;
}

#Scoreboard_body tr:hover td.score,
#Scoreboard_body tr.selected td.score,
#Scoreboard_body tr td.score.sort_key {
    opacity: 1;
}

.score_0 {
    background-color: #F40000;
    /*background-image: linear-gradient(rgb(204, 0, 0), rgb(244, 0, 0));*/
}

.score_0_10 {
    background-color: #EB1D00;
    /*background-image: linear-gradient(rgb(210, 38, 0), rgb(235, 29, 0));*/
}

.score_10_20 {
    background-color: #E23A00;
    /*background-image: linear-gradient(rgb(216, 77, 0), rgb(226, 58, 0));*/
}

.score_20_30 {
    background-color: #D95700;
    /*background-image: linear-gradient(rgb(222, 115, 0), rgb(217, 87, 0));*/
}

.score_30_40 {
    background-color: #D17400;
    /*background-image: linear-gradient(rgb(228, 154, 0), rgb(209, 116, 0));*/
}

.score_40_50 {
    background-color: #C89100;
    /*background-image: linear-gradient(rgb(234, 192, 0), rgb(200, 145, 0));*/
}

.score_50_60 {
    background-color: #B99F00;
    /*background-image: linear-gradient(rgb(225, 211, 2), rgb(185, 159, 0));*/
}

.score_60_70 {
    background-color: #A39E01;
    /*background-image: linear-gradient(rgb(203, 211, 6), rgb(163, 158, 1));*/
}

.score_70_80 {
    background-color: #8E9D02;
    /*background-image: linear-gradient(rgb(181, 211, 10), rgb(142, 157, 2));*/
}

.score_80_90 {
    background-color: #789C03;
    /*background-image: linear-gradient(rgb(159, 210, 14), rgb(120, 156, 3));*/
}

.score_90_100 {
    background-color: #639B04;
    /*background-image: linear-gradient(rgb(137, 210, 18), rgb(99, 155, 4));*/
}

.score_100 {
    background-color: #4E9A05;
    /*background-image: linear-gradient(rgb(115, 210, 22), rgb(78, 154, 5));*/
}


/******************************************************************************\
|                                                                              |
|                                   User panel                                 |
|                                   ----------                                 |
\******************************************************************************/


#UserDetail_bg {
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 500;
    background-color: rgba(0,0,0,0.5);
    overflow-y: scroll;
    /* the following two lines are for IE */
    -ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr=#80000000, endColorstr=#80000000)";
    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#80000000, endColorstr=#80000000);
}

#UserDetail_bg.open {
    display: block;
}

#UserDetail {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    width: 920px;
    margin: 48px auto;
    padding: 20px;
    border-radius: 12px;
    background-color: white;
}

#UserDetail_close {
    position: absolute;
    top: -10px;
    right: -10px;
    width: 24px;
    height: 24px;
    cursor: pointer;
}

#UserDetail_header {
    position: relative;
    min-height: 242px;
}

#UserDetail_f_name,
#UserDetail_l_name,
#UserDetail_team,
#UserDetail_flag {
    position: absolute;
    right: 470px;
    font-size: 2em;
    line-height: 1.5em;
}

#UserDetail_f_name {
    top: 0;
}

#UserDetail_l_name {
    top: 1.5em;
}

#UserDetail_team {
    bottom: 100px;
}

#UserDetail_flag {
    bottom: 0;
}

#UserDetail_face {
    position: absolute;
    top: 0;
    left: 0;
    max-width: 160px;
    max-height: 240px;
}

#UserDetail_flag {
    margin: -1px;
    border: 1px solid gray;
}

#UserDetail_flag.hidden {
    display: none;
}

#UserDetail_navigator {
    width: 450px;
    margin-left: 470px;
}

#UserDetail_navigator table {
    width: 100%;
    table-layout: fixed;
    border-spacing: 2px;
}

#UserDetail_navigator tr {
    height: 22px;
}

#UserDetail_navigator col.name {
    width: 60%;
}

#UserDetail_navigator col.score,
#UserDetail_navigator col.rank {
    width: 12%;
}

#UserDetail_navigator col.show {
    width: 14%;
}

#UserDetail_navigator tr td.score,
#UserDetail_navigator tr td.rank {
    padding-left: 4px;
}

#UserDetail_navigator tbody tr td.btn {
    text-align: center;
    border: 1px solid #999999;
    box-shadow: 0 0 2px gray;
    background-color: #EEEEEE;
    border-radius: 3px;
    cursor: pointer;
    -webkit-user-select: none;
     -khtml-user-select: none;
       -moz-user-select: none;
         -o-user-select: none;
            user-select: none;
}

#UserDetail_navigator tbody tr td.btn:hover {
    background-color: #DDDDDD;
}

#UserDetail_navigator tbody tr td.btn:active {
    background-color: #CCCCCC;
}

#UserDetail_navigator tbody tr.active td.btn {
    background-color: #EEEEEE;
    opacity: 0.4;
    cursor: default;
    /* the following two lines are for IE */
    -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=40)";
    filter: alpha(opacity=40);
}

#UserDetail_navigator tr.global {
    background-color: #DDDDDD;
}

#UserDetail_navigator tr.contest {
    background-color: #EEEEEE;
}

#UserDetail_navigator tr.task {
    background-color: #FFFFFF;
}

#UserDetail_navigator tr.global td.name {
    padding-left: 5px;
}

#UserDetail_navigator tr.contest td.name {
    padding-left: 25px;
}

#UserDetail_navigator tr.task td.name {
    padding-left: 45px;
}

#UserDetail_title {
    margin-top: 24px;
    font-size: 2em;
    line-height: 1.5em;
    text-align: center;
}

#UserDetail_charts {
    margin-top: 24px;
    width: 100%;
}

#UserDetail_submissions {
    margin-top: 24px;
    width: 100%;
}

#UserDetail_submissions:empty {
    margin-top: 0;
}

#UserDetail_submissions table {
    width: 100%;
    table-layout: fixed;
}

#UserDetail_submissions td {
    height: 22px;
    padding-left: 4px;
}

#UserDetail_submissions thead {
    background-color: #DDDDDD;
}

#UserDetail_submissions tbody tr:nth-child(even) {
    background-color: #EEEEEE;
}

#UserDetail_submissions tbody tr:nth-child(odd) {
    background-color: #F8F8F8;
}

#UserDetail_submissions tbody td[colspan] {
    text-align: center;
    font-style: italic;
}


/* Style for the network status indicator */

#ConnectionStatus_box {
    display: inline-block;
    position: relative;
    float: right;
    margin: 0.5em;
    text-align: right;
    z-index: 2;
}

#ConnectionStatus_label {
    display: inline-block;
    position: relative;
    height: 1.5em;
    padding: 0.25em 20px;
    margin: -1px 0;
    z-index: 2;
    border-width: 1px;
    border-style: solid;
    border-radius: 4px;
    -webkit-user-select: none;
       -moz-user-select: none;
        -ms-user-select: none;
         -o-user-select: none;
            user-select: none;
}

#ConnectionStatus_box:hover #ConnectionStatus_label {
    border-bottom-width: 0;
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
}

#ConnectionStatus_text {
    display: none;
    position: absolute;
    top: 2em;
    right: 0;
    width: 240px;
    padding: 0.5em;
    margin-top: -1px;
    z-index: 1;
    border-width: 1px;
    border-style: solid;
    border-radius: 4px 0 4px 4px;
}

#ConnectionStatus_box:hover #ConnectionStatus_text,
#ConnectionStatus_text:hover {
    display: block;
}

#ConnectionStatus_box[data-status="connected"] #ConnectionStatus_label,
#ConnectionStatus_box[data-status="connected"] #ConnectionStatus_text {
    background-color: white;
    color: green;
    border-color: green;
}

#ConnectionStatus_box[data-status="reconnecting"] #ConnectionStatus_label,
#ConnectionStatus_box[data-status="reconnecting"] #ConnectionStatus_text {
    background-color: yellow;
    color: black;
    border-color: black;
}

#ConnectionStatus_box[data-status="disconnected"] #ConnectionStatus_label,
#ConnectionStatus_box[data-status="disconnected"] #ConnectionStatus_text,
#ConnectionStatus_box[data-status="outdated"] #ConnectionStatus_label,
#ConnectionStatus_box[data-status="outdated"] #ConnectionStatus_text,
#ConnectionStatus_box[data-status="init_error"] #ConnectionStatus_label,
#ConnectionStatus_box[data-status="init_error"] #ConnectionStatus_text {
    background-color: red;
    color: white;
    border-color: red;
}

#ConnectionStatus_box a {
    cursor: pointer;
    text-decoration: underline;
}
/* Programming contest management system
 * Copyright © 2012 Luca Wehrstedt <luca.wehrstedt@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

if (!window.console) {
    window.console = new Object();
}

if (!window.console.log) {
    window.console.log = function () {};
}

if (!window.console.info) {
    window.console.info = function () {};
}

if (!window.console.warn) {
    window.console.warn = function () {};
}

if (!window.console.error) {
    window.console.error = function () {};
}

$(document).ready(function() {
    DataStore.init(function(){
        HistoryStore.init();
        UserDetail.init();
        TimeView.init();
        TeamSearch.init();
        Overview.init();
        Scoreboard.init();
    });
});
/* Programming contest management system
 * Copyright © 2012 Luca Wehrstedt <luca.wehrstedt@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

var escapeHTML = (function() {
    var escapeMap = {
        '&' : '&amp;',
        '<' : '&lt;',
        '>' : '&gt;',
        '"' : '&quot;',
        "'" : '&#x27;',
        '/' : '&#x2F;',
        '`' : '&#x60;'
    };
    var escapeHTML = function(str) {
        return String(str).replace(/[&<>"'\/`]/g, function(ch) {
            return escapeMap[ch];
        });
    };
    return escapeHTML;
})();

var Scoreboard = new function () {
    var self = this;

    self.init = function () {
        self.tcols_el = $('#Scoreboard_cols');
        self.thead_el = $('#Scoreboard_head');
        self.tbody_el = $('#Scoreboard_body');

        self.generate();

        DataStore.user_create.add(self.create_user);
        DataStore.user_update.add(self.update_user);
        DataStore.user_delete.add(self.delete_user);

        DataStore.score_events.add(self.score_handler);
        DataStore.rank_events.add(self.rank_handler);
        DataStore.select_events.add(self.select_handler);
    };


    self.generate = function () {
        self.tcols_el.html(self.make_cols());
        self.thead_el.html(self.make_head());

        // Create callbacks for sorting
        self.thead_el.on("click", "th.score", function () {
            $("col[data-sort_key=" + self.sort_key + "]", self.tcols_el).removeClass("sort_key");
            $("tr td[data-sort_key=" + self.sort_key + "]", self.thead_el).removeClass("sort_key");
            $("tr td[data-sort_key=" + self.sort_key + "]", self.tbody_el).removeClass("sort_key");

            var $this = $(this);

            if ($this.hasClass("global")) {
                self.sort_key = "global";
            } else if ($this.hasClass("contest")) {
                self.sort_key = "c_" + $this.data("contest");
            } else if ($this.hasClass("task")) {
                self.sort_key = "t_" + $this.data("task");
            }

            self.sort();

            $("col[data-sort_key=" + self.sort_key + "]", self.tcols_el).addClass("sort_key");
            $("tr td[data-sort_key=" + self.sort_key + "]", self.thead_el).addClass("sort_key");
            $("tr td[data-sort_key=" + self.sort_key + "]", self.tbody_el).addClass("sort_key");
        });

        self.sort_key = "global";
        self.make_body();

        // Set initial style
        $("col[data-sort_key=" + self.sort_key + "]", self.tcols_el).addClass("sort_key");
        $("tr td[data-sort_key=" + self.sort_key + "]", self.thead_el).addClass("sort_key");
        $("tr td[data-sort_key=" + self.sort_key + "]", self.tbody_el).addClass("sort_key");

        // Create callbacks for selection
        self.tbody_el.on("click", "td.sel", function () {
            DataStore.toggle_selected($(this).parent().data("user"));
        });

        // Create callbacks for UserPanel
        self.tbody_el.on("click", "td.f_name, td.l_name", function () {
            UserDetail.show($(this).parent().data("user"));
        });

        // Create callbacks for animation-end
        self.tbody_el.on('animationend', 'tr', function(event) {
            $(this).removeClass("score_up score_down");
        });

        // Fuck, WebKit!!
        self.tbody_el.on('webkitAnimationEnd', 'tr', function(event) {
            $(this).removeClass("score_up score_down");
        });
    };


    self.make_cols = function () {
        // We want some columns to have a fixed, constant width at all screen
        // sizes (i.e. the sel, rank and team columns) while having the other
        // columns scale accoring to the available horizontal space. Yet, we
        // also want these columns' widths to keep a certain ratio one to each
        // other, for example the task score, contest score and global score
        // columns should be in a 3:4:5 ratio. Since the number of columns is
        // not known beforehand, this is quite difficult to achieve.
        // We cannot specify all the widths using pixel sizes (or similar)
        // because when there are many tasks the table may overflow, and when
        // there are few tasks it may underflow (and, in such cases, the
        // remaining width is divided proportionally among all columns, thus
        // enlarging the constant width columns too). We cannot use relative
        // widths (i.e. using precent values) because it seems that some
        // versions of IE don't like it when the sum of the widths is greater
        // than 100% (and this may happen when there are many tasks).
        // We cannot use an 'auto' width on all columns because this would not
        // preserve the ratio among widths.
        // We cannot mix fixed/percent/auto widths because, depending on the
        // way we do it, the solution may not scale well at high resolutions or
        // it may again be difficult to keep the ratio that we want.
        // Also, I would like not to use JS or strange HTML constructions to
        // achieve this goal: it would be great if we could do this using just
        // simple CSS rules.
        // I couldn't find the perfect solution, so the one I'm implementing is
        // a bit of a compromise, which tries to mess as little as possible
        // with JS and HTML. So, at the moment, this is what we do: we set the
        // columns with fixed width to their fixed width (via CSS). We don't
        // define a width for all other columns, thus leaving them at their
        // default value: auto. Yet, we don't create a single <col/> element
        // for each column, but we create 3 for the task columns, 4 for the
        // contest columns, 5 for the global column, etc. Then we set the
        // colspan attribute of task cells to 3, of contest cells to 4, of
        // global cells to 5, etc. This way, since all <col/>s with a width of
        // 'auto' get the same computed width, we keep the 3:4:5 ratio and are
        // able to scale well at each screen size, while keeping the constant
        // width columns constant. (Note: we gave the first_ and last_name
        // columns a "width" of 10 <col/> elements.)
        // Suggestion on other solution that get the same result and don't mess
        // this much with JS and HTML are extremely welcome!
        var result = " \
<col class=\"sel\"/> \
<col class=\"rank\"/> \
<col class=\"f_name\"/> <col/><col/><col/><col/><col/><col/><col/><col/><col/> \
<col class=\"l_name\"/> <col/><col/><col/><col/><col/><col/><col/><col/><col/> \
<col class=\"team\"/>";

        var contests = DataStore.contest_list;
        for (var i in contests) {
            var contest = contests[i];
            var c_id = contest["key"];

            var tasks = contest["tasks"];
            for (var j in tasks) {
                var task = tasks[j];
                var t_id = task["key"];

                result += " \
<col class=\"score task\" data-task=\"" + t_id + "\" data-sort_key=\"t_" + t_id + "\"/> <col/><col/>";
            }

            result += " \
<col class=\"score contest\" data-contest=\"" + c_id + "\" data-sort_key=\"c_" + c_id + "\"/> <col/><col/><col/>";
        }

        result += " \
<col class=\"score global\" data-sort_key=\"global\"/> <col/><col/><col/><col/>";

        return result;
    };


    self.make_head = function () {
        // See the comment in .make_cols() for the reason we use colspans.
        var result = " \
<tr> \
    <th class=\"sel\"></th> \
    <th class=\"rank\">Rank</th> \
    <th colspan=\"10\" class=\"f_name\">First Name</th> \
    <th colspan=\"10\" class=\"l_name\">Last Name</th> \
    <th class=\"team\">Team</th>";

        var contests = DataStore.contest_list;
        for (var i in contests) {
            var contest = contests[i];
            var c_id = contest["key"];

            var tasks = contest["tasks"];
            for (var j in tasks) {
                var task = tasks[j];
                var t_id = task["key"];

                result += " \
    <th colspan=\"3\" class=\"score task\" data-task=\"" + t_id + "\" data-sort_key=\"t_" + t_id + "\"><abbr title=\"" + escapeHTML(task["name"]) + "\">" + escapeHTML(task["short_name"]) + "</abbr></th>";
            }

            result += " \
    <th colspan=\"4\" class=\"score contest\" data-contest=\"" + c_id + "\" data-sort_key=\"c_" + c_id + "\"><abbr title=\"" + escapeHTML(contest["name"]) + "\">" + escapeHTML(contest["name"]) + "</abbr></th>";
        }

        result += " \
    <th colspan=\"5\" class=\"score global\" data-sort_key=\"global\">Global</th> \
</tr>";

        return result;
    };


    self.make_body = function () {
        for (var u_id in DataStore.users) {
            var user = DataStore.users[u_id];
            user["row"] = $(self.make_row(user))[0];
            self.user_list.push(user);
        }

        self.sort();
    };


    self.make_row = function (user) {
        // See the comment in .make_cols() for the reason we use colspans.
        var result = " \
<tr class=\"user" + (user["selected"] > 0 ? " selected color" + user["selected"] : "") + "\" data-user=\"" + user["key"] + "\"> \
    <td class=\"sel\"></td> \
    <td class=\"rank\">" + user["rank"] + "</td> \
    <td colspan=\"10\" class=\"f_name\">" + escapeHTML(user["f_name"]) + "</td> \
    <td colspan=\"10\" class=\"l_name\">" + escapeHTML(user["l_name"]) + "</td>";

        if (user['team']) {
            result += " \
    <td class=\"team\"><img src=\"" + Config.get_flag_url(user["team"]) + "\" title=\"" + DataStore.teams[user["team"]]["name"] + "\" /></td>";
        } else {
            result += " \
    <td class=\"team\"></td>";
        }

        var contests = DataStore.contest_list;
        for (var i in contests) {
            var contest = contests[i];
            var c_id = contest["key"];

            var tasks = contest["tasks"];
            for (var j in tasks) {
                var task = tasks[j];
                var t_id = task["key"];

                var score_class = self.get_score_class(user["t_" + t_id], task["max_score"]);
                result += " \
    <td colspan=\"3\" class=\"score task " + score_class + "\" data-task=\"" + t_id + "\" data-sort_key=\"t_" + t_id + "\">" + round_to_str(user["t_" + t_id], task["score_precision"]) + "</td>";
            }

            var score_class = self.get_score_class(user["c_" + c_id], contest["max_score"]);
            result += " \
    <td colspan=\"4\" class=\"score contest " + score_class + "\" data-contest=\"" + c_id + "\" data-sort_key=\"c_" + c_id + "\">" + round_to_str(user["c_" + c_id], contest["score_precision"]) + "</td>";
        }

        var score_class = self.get_score_class(user["global"], DataStore.global_max_score);
        result += " \
    <td colspan=\"5\" class=\"score global " + score_class + "\" data-sort_key=\"global\">" + round_to_str(user["global"], DataStore.global_score_precision) + "</td> \
</tr>";

        return result;
    };


    self.get_score_class = function (score, max_score) {
        if (score <= 0) {
            return "score_0";
        } else if (score >= max_score) {
            return "score_100";
        } else {
            var rel_score = parseInt(score / max_score * 10) * 10;
            return "score_" + rel_score + "_" + (rel_score + 10);
        }
    };


    // We keep a sorted list of user that represent the current order of the
    // scoreboard. In particular we sort using these keys:
    // - the score in the current active column
    // - the global score
    // - the last name
    // - the first name
    // - the key
    self.user_list = new Array();


    // Compare two users. Returns -1 if "a < b" or +1 if "a >= b"
    // (where a < b means that a shoud go above b in the scoreboard)
    self.compare_users = function (a, b) {
        var sort_key = self.sort_key;
        if ((a[sort_key] > b[sort_key]) || ((a[sort_key] == b[sort_key]) &&
           ((a["global"] > b["global"]) || ((a["global"] == b["global"]) &&
           ((a["l_name"] < b["l_name"]) || ((a["l_name"] == b["l_name"]) &&
           ((a["f_name"] < b["f_name"]) || ((a["f_name"] == b["f_name"]) &&
           (a["key"] <= b["key"]))))))))) {
            return -1;
        } else {
            return +1;
        }
    };


    // Suppose the scoreboard is correctly sorted except for the given user.
    // Move this user (up or down) to put it in their correct position.
    self.move_user = function (user) {
        var list = self.user_list;
        var compare = self.compare_users;

        var list_l = list.length;
        var i = parseInt(user["index"]);

        if (i > 0 && compare(user, list[i-1]) == -1) {
            // Move up

            while (i > 0 && compare(user, list[i-1]) == -1) {
                list[i] = list[i-1];
                list[i]["index"] = i;
                i -= 1;
            }
            list[i] = user;
            user["index"] = i;

            if (i == 0) {
                self.tbody_el.prepend(user["row"]);
            } else {
                self.tbody_el.children("tr.user[data-user=" + list[i-1]["key"] + "]").after(user["row"]);
            }
        } else if (i < list_l-1 && compare(list[i+1], user) == -1) {
            // Move down

            while (i < list_l-1 && compare(list[i+1], user) == -1) {
                list[i] = list[i+1];
                list[i]["index"] = i;
                i += 1;
            }
            list[i] = user;
            user["index"] = i;

            if (i == list_l-1) {
                self.tbody_el.append(user["row"]);
            } else {
                self.tbody_el.children("tr.user[data-user=" + list[i+1]["key"] + "]").before(user["row"]);
            }
        }
    };


    // Sort the scoreboard using the column with the given index.
    self.sort = function () {
        var list = self.user_list;

        list.sort(self.compare_users);

        var fragment = document.createDocumentFragment();
        for (var idx in list)
        {
            list[idx]["index"] = idx;
            fragment.appendChild(list[idx]["row"]);
        }

        self.tbody_el.append(fragment);
    };


    // This callback is called by the DataStore when a user is created.
    self.create_user = function (u_id, user) {
        var $row = $(self.make_row(user));
        $row.children("td[data-sort_key=" + self.sort_key + "]").addClass("sort_key");

        user["row"] = $row[0];
        user["index"] = self.user_list.length;
        self.user_list.push(user);

        self.tbody_el.append(row);
        // The row will be at the bottom (since it has a score of zero and thus
        // the maximum rank), but we may still need to sort it due to other
        // users having that score and the sort-by-name clause.
        self.move_user(user);
    };


    // This callback is called by the DataStore when a user is updated.
    // It updates only its basic information (first name, last name and team).
    self.update_user = function (u_id, old_user, user) {
        var $row = $(old_user["row"]);

        user["row"] = old_user["row"];
        user["index"] = old_user["index"];
        self.user_list.splice(old_user["index"], 1, user);
        delete old_user["row"];
        delete old_user["index"];

        $row.children("td.f_name").text(user["f_name"]);
        $row.children("td.l_name").text(user["l_name"]);

        if (user["team"]) {
            $row.children(".team").html("<img src=\"" + Config.get_flag_url(user["team"]) + "\" title=\"" + DataStore.teams[user["team"]]["name"] + "\" />");
        } else {
            $row.children(".team").text("");
        }
    };


    // This callback is called by the DataStore when a user is deleted.
    self.delete_user = function (u_id, old_user) {
        var $row = $(old_user["row"]);

        self.user_list.splice(old_user["index"], 1);
        delete old_user["row"];
        delete old_user["index"];

        $row.remove();
    };


    // This callback is called by the DataStore when a user changes score.
    self.score_handler = function (u_id, user, t_id, task, delta) {
        var $row = $(user["row"]);

        // TODO improve this method: avoid walking over all cells

        $row.children("td.score").each(function () {
            var $this = $(this);

            var score = user[$this.data("sort_key")];

            if ($this.hasClass("global")) {
                var max_score = DataStore.global_max_score;
                $this.text(round_to_str(score, DataStore.global_score_precision));
            } else if ($this.hasClass("contest")) {
                var contest = DataStore.contests[$this.data("contest")];
                var max_score = contest["max_score"];
                $this.text(round_to_str(score, contest["score_precision"]));
            } else if ($this.hasClass("task")) {
                var task = DataStore.tasks[$this.data("task")];
                var max_score = task["max_score"];
                $this.text(round_to_str(score, task["score_precision"]));
            }

            // TODO we could user a data-* attribute to store the score class

            var score_class = self.get_score_class(score, max_score);
            $this.removeClass("score_0 score_0_10 score_10_20 score_20_30 score_30_40 score_40_50 score_50_60 score_60_70 score_70_80 score_80_90 score_90_100 score_100");
            $this.addClass(score_class);
        });

        self.move_user(user);

        // Restart CSS animation
        $row.removeClass("score_up score_down");
        if (delta > 0) {
            $row.addClass("score_up");
        } else if (delta < 0) {
            $row.addClass("score_down");
        }
    };


    // This callback is called by the DataStore when a user changes rank.
    self.rank_handler = function (u_id, user) {
        var $row = $(user["row"]);

        $row.children("td.rank").text(user["rank"]);
    };


    self.select_handler = function (u_id, color) {
        var $row = $(DataStore.users[u_id]["row"]);

        // TODO we could user a data-* attribute to store the color

        if (color != 0) {
            $row.addClass("selected color" + color);
        } else {
            $row.removeClass("selected color1 color2 color3 color4 color5 color6 color7 color8");
        }
    };

    self.scroll_into_view = function (u_id) {
        var $row = $("tr.user[data-user=" + u_id + "]", self.tbody_el);
        var $frame = $("#InnerFrame");
        var scroll = $row.position().top + $frame.scrollTop() + $row.height() / 2 - $frame.height() / 2;
        $frame.scrollTop(scroll);
    };
};
{
    "EthanChiu6": {
        "C": 100.0,
        "A": 100.0,
        "B": 100.0,
        "D": 100.0,
        "K1": 100.0,
        "I": 20.0
    },
    "sc.1101.rex": {
        "A": 100.0,
        "B": 100.0,
        "C": 40.0,
        "K1": 100.0
    },
    "Jasper7": {
        "A": 100.0,
        "B": 100.0,
        "C": 100.0
    },
    "RayYu": {
        "A": 100.0,
        "B": 100.0,
        "C": 100.0
    },
    "PureDevr": {
        "A": 100.0,
        "B": 100.0,
        "C": 100.0
    },
    "Kyle_Ho": {
        "A": 100.0,
        "K1": 100.0
    },
    "jeff_wu0302": {
        "A": 100.0,
        "B": 100.0,
        "J": 20.0,
        "H1": 30.0
    },
    "ericaaaaa": {
        "A": 100.0,
        "B": 32.0
    },
    "cam196883": {
        "B": 32.0,
        "A": 100.0
    }
}/* Programming contest management system
 * Copyright © 2012 Luca Wehrstedt <luca.wehrstedt@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

var TeamSearch = new function () {
    var self = this;

    self.init = function () {
        $("#TeamSearch_input").focus(function () {
            self.show();
        });

        $("#TeamSearch_bg").click(function (event) {
            if (event.target == event.currentTarget) {
                self.hide();
            }
        });

        $("#TeamSearch_close").click(function () {
            self.hide();
        });

        /** Update the list when the value in the search box changes */

        /* This event is very problematic:
           * The `change' event is a standard (and I think it's correctly
             supported almost everywhere) but it gets fired only when the
             element loses focus.
           * the `input' event does what we want but it doesn't exists in IE
             (except in version 9, where it's buggy: it doesn't get fired when
             characters are deleted);
           * the `propertychange' event is the IE-equivalent event, but it's
             also buggy in IE9 (in the same way);
           * the `keypress' event provided by JQuery (which isn't standard and
             thus may vary among browsers) seems to get fired too early, when
             the value of the input hasn't yet been updated (so we read the
             value _before_ it gets changed);
           * the `keydown' event seems to be more standard, but it has the same
             disadvantage as the `keypress': it's fired too early; in addition,
             it gets fired only once when the key is held down (while keypress
             is fire repeatedly, once for each new character).
           * the `keyup' event should solve the first issue of `keydown' but
             not the second: it's only fired at the end of a series of
             `keypress' events.
           * cutting text is another way to delete characters, thus we'll need
             to listen to `cut' events in IE9 to workaround the buggy `input'.
           Suggestions are welcome.
        */

        /* I decided to listen on `input' and `propertychange' since they
           should work everywhere except IE9. On IE9 some (conditional) code
           will also listen to the `keyup' and `cut' events and try to detect
           when some text is deleted.
         */

        $("#TeamSearch_input").on("input", function () {
            self.update();
        });

        $("#TeamSearch_input").on("propertychange", function () {
            self.update();
        });

/*@cc_on
    @if (@_jscript_version == 9)

        $("#TeamSearch_input").keyup(function (event) {
            switch (event.which) {
                case 8:  // backspace
                case 46:  // delete
                    self.update();
            }
        });

        $("#TeamSearch_input").on("cut", function () {
            self.update();
        });

    @end
@*/

        self.body = $('#TeamSearch_body');

        self.generate();
        self.update();

        DataStore.select_events.add(self.select_handler);
    };

    self.generate = function () {
        self.sel = new Object();
        self.cnt = new Object();

        for (var t_id in DataStore.teams) {
            self.sel[t_id] = 0;
            self.cnt[t_id] = DataStore.teams[t_id]["users"].length;
        }

        var inner_html = "";

        // We're iterating on the team_list (instead of teams) to get the teams
        // in lexicographic order of name
        for (var i in DataStore.team_list) {
            var team = DataStore.team_list[i];
            var t_id = team["key"];
            inner_html += " \
<div class=\"item\" data-team=\"" + t_id + "\"> \
    <label> \
        <input type=\"checkbox\"/> \
        <img class=\"flag\" src=\"" + Config.get_flag_url(t_id) + "\" /> " + team['name'] + " \
    </label> \
</div>";
        }

        self.body.html(inner_html);

        self.body.on("change", "input[type=checkbox]", function () {
            var $this = $(this);

            var users = DataStore.teams[$this.parent().parent().data("team")]["users"];
            var status = $this.prop("checked");

            for (var i in users) {
                DataStore.set_selected(users[i]["key"], status);
            }
        });
    };

    self.select_handler = function (u_id, flag) {
        var user = DataStore.users[u_id];
        var t_id = user['team'];

        if (!t_id) {
            return;
        }

        if (flag) {
            self.sel[t_id] += 1;
        } else {
            self.sel[t_id] -= 1;
        }

        var $elem = $("div.item[data-team=" + t_id + "] input[type=checkbox]", self.body);
        if (self.sel[t_id] == self.cnt[t_id]) {
            $elem.prop("checked", true);
            $elem.prop("indeterminate", false);
        } else if (self.sel[t_id] > 0) {
            $elem.prop("checked", true);
            $elem.prop("indeterminate", true);
        } else {
            $elem.prop("checked", false);
            $elem.prop("indeterminate", false);
        }
    };

    self.show = function () {
        $("#TeamSearch_bg").addClass("open");
    };

    self.hide = function () {
        $("#TeamSearch_bg").removeClass("open");
    };

    self.update = function () {
        var search_text = $("#TeamSearch_input").val();

        if (search_text == "") {
            $('div.item', self.t_body).removeClass("hidden");
        } else {
            // FIXME We could store the lowercased name of the team on the divs
            // and then just use a query like [attribute*="value"] (with value
            // set to the lowercased search_text) and add the class to that.
            // (We would need another query to get the complementary set).
            for (var t_id in DataStore.teams) {
                var team = DataStore.teams[t_id];
                if (team["name"].toLowerCase().indexOf(search_text.toLowerCase()) == -1) {
                    $("div.item[data-team=" + t_id + "]", self.body).addClass("hidden");
                } else {
                    $("div.item[data-team=" + t_id + "]", self.body).removeClass("hidden");
                }
            }
        }
    };
};
/* Programming contest management system
 * Copyright © 2012 Luca Wehrstedt <luca.wehrstedt@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

function format_time(time, full) {
    var h = Math.floor(time / 3600);
    var m = Math.floor((time % 3600) / 60);
    var s = Math.floor(time % 60);
    h = full && h < 10 ? "0" + h : "" + h;
    m = m < 10 ? "0" + m : "" + m;
    s = s < 10 ? "0" + s : "" + s;
    return (h + ":" + m + ":" + s);
};

function _get_time() {
    // Return the seconds since January 1, 1970 00:00:00 UTC
    return $.now() / 1000;
}

var TimeView = new function () {
    var self = this;

    // possible values:
    // - 0: elapsed time
    // - 1: remaining time
    // - 2: current (clock) time
    self.status = 0;

    self.init = function () {
        window.setInterval(function() {
            self.on_timer();
        }, 1000);
        self.on_timer();

        $("#TimeView_selector_elapsed").click(function () {
            self.status = 0;
            self.on_timer();
            $("#TimeView_selector").removeClass("open");
        });

        $("#TimeView_selector_remaining").click(function () {
            self.status = 1;
            self.on_timer();
            $("#TimeView_selector").removeClass("open");
        });

        $("#TimeView_selector_current").click(function () {
            self.status = 2;
            self.on_timer();
            $("#TimeView_selector").removeClass("open");
        });

        $("#TimeView_expand").click(function () {
            $("#TimeView_selector").toggleClass("open");
        });

        $("#TimeView_selector").click(function (event) {
            event.stopPropagation();
            return false;
        });

        $("body").on("click", function () {
            $("#TimeView_selector").removeClass("open");
        })
    };

    self.on_timer = function () {
        var cur_time = _get_time();
        var c = null;

        // contests are iterated sorted by begin time
        // and the first one that's still running is chosen
        for (var j in DataStore.contest_list) {
            var contest = DataStore.contest_list[j];
            if (cur_time <= contest['end']) {
                c = contest;
                break;
            }
        }

        if (c == null) {
            $("#TimeView_name").text();
        } else {
            $("#TimeView_name").text(c["name"]);
        }

        var date = new Date(cur_time * 1000);
        var today = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        var time = cur_time - today.getTime() / 1000;

        var full_time = false;

        if (c == null) {
            // no "next contest": always show the clock
            $("#TimeView").removeClass("elapsed remaining pre_cont cont");
            $("#TimeView").addClass("current post_cont");
            full_time = true;
        } else {
            if (cur_time < c['begin']) {
                // the next contest has yet to start: show remaining or clock
                $("#TimeView").removeClass("cont post_cont");
                $("#TimeView").addClass("pre_cont");
                if (self.status == 2) {
                    $("#TimeView").removeClass("elapsed remaining");
                    $("#TimeView").addClass("current");
                    full_time = true;
                } else {
                    $("#TimeView").removeClass("elapsed current");
                    $("#TimeView").addClass("remaining");
                    time = cur_time - c['begin'];
                }
            } else {
                // the next contest already started: all options available
                $("#TimeView").removeClass("pre_cont post_cont");
                $("#TimeView").addClass("cont");
                if (self.status == 2) {
                    $("#TimeView").removeClass("elapsed remaining");
                    $("#TimeView").addClass("current");
                    full_time = true;
                } else if (self.status == 1) {
                    $("#TimeView").removeClass("elapsed current");
                    $("#TimeView").addClass("remaining");
                    time = cur_time - c['end'];
                } else {
                    $("#TimeView").removeClass("remaining current");
                    $("#TimeView").addClass("elapsed");
                    time = cur_time - c['begin'];
                }
            }
        }

        var time_str = format_time(Math.abs(Math.floor(time)), full_time);
        if (time < 0) {
            time_str = '-' + time_str;
        }

        $("#TimeView_time").text(time_str);
    };
};
/* Programming contest management system
 * Copyright © 2012 Luca Wehrstedt <luca.wehrstedt@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

// format_time is defined in TimeView

var UserDetail = new function () {
    var self = this;

    self.init = function () {
        $("#UserDetail_bg").click(function (event) {
            if (event.target == event.currentTarget) {
                self.hide();
            }
        });

        $("#UserDetail_close").click(function () {
            self.hide();
        });

        $(document).keyup(function (event) {
            if (event.keyCode == 27) { // ESC key
                self.hide();
            }
        });

        self.f_name_label = $('#UserDetail_f_name');
        self.l_name_label = $('#UserDetail_l_name');
        self.team_label = $('#UserDetail_team');
        self.flag_image = $('#UserDetail_flag');
        self.face_image = $('#UserDetail_face');
        self.title_label = $('#UserDetail_title');

        self.navigator = $('#UserDetail_navigator table tbody');
        self.submission_table = $('#UserDetail_submissions');

        self.score_chart = $('#UserDetail_score_chart')[0];
        self.rank_chart = $('#UserDetail_rank_chart')[0];

        self.navigator.on("click", "td.btn", function () {
            if (self.active !== null) {
                self.active.removeClass("active");
            }
            self.active = $(this).parent();
            self.active.addClass("active");

            if (self.active.hasClass('global')) {
                self.show_global();
            } else if (self.active.hasClass('contest')) {
                self.show_contest(self.active.attr('data-contest'));
            } else if (self.active.hasClass('task')) {
                self.show_task(self.active.attr('data-task'));
            }
        });
    };

    self.show = function (user_id) {
        self.user_id = user_id;
        self.user = DataStore.users[user_id];
        self.data_fetched = 0;
        HistoryStore.request_update(self.history_callback);

        $.ajax({
            url: Config.get_submissions_url(self.user_id),
            dataType: "json",
            success: self.submissions_callback,
            error: function () {
                console.error("Error while getting the submissions for " + self.user_id);
            }
        });
    };

    self.history_callback = function () {
        self.task_s = new Object();
        self.task_r = new Object();
        for (var t_id in DataStore.tasks) {
            self.task_s[t_id] = HistoryStore.get_score_history_for_task(self.user_id, t_id);
            self.task_r[t_id] = HistoryStore.get_rank_history_for_task(self.user_id, t_id);
        }

        self.contest_s = new Object();
        self.contest_r = new Object();
        for (var c_id in DataStore.contests) {
            self.contest_s[c_id] = HistoryStore.get_score_history_for_contest(self.user_id, c_id);
            self.contest_r[c_id] = HistoryStore.get_rank_history_for_contest(self.user_id, c_id);
        }

        self.global_s = HistoryStore.get_score_history(self.user_id);
        self.global_r = HistoryStore.get_rank_history(self.user_id);

        self.data_fetched += 1;
        self.do_show();
    }

    self.submissions_callback = function (data) {
        self.submissions = new Object();
        for (var t_id in DataStore.tasks) {
            self.submissions[t_id] = new Array();
        }
        for (var i = 0; i < data.length; i += 1) {
            var submission = data[i];
            self.submissions[submission['task']].push(submission);
        }

        self.data_fetched += 1;
        self.do_show();
    };

    self.do_show = function () {
        if (self.data_fetched == 2) {
            self.f_name_label.text(self.user["f_name"]);
            self.l_name_label.text(self.user["l_name"]);
            self.face_image.attr("src", Config.get_face_url(self.user_id));

            if (self.user["team"]) {
                self.team_label.text(DataStore.teams[self.user["team"]]["name"]);
                self.flag_image.attr("src", Config.get_flag_url(self.user['team']));
                self.flag_image.removeClass("hidden");
            } else {
                self.team_label.text("");
                self.flag_image.addClass("hidden");
            }

            var s = "<tr class=\"global\"> \
                        <td class=\"name\">Global</td> \
                        <td class=\"score\">" + (self.global_s.length > 0 ? round_to_str(self.global_s[self.global_s.length-1][1], DataStore.global_score_precision) : 0) + "</td> \
                        <td class=\"rank\">" + (self.global_r.length > 0 ? self.global_r[self.global_r.length-1][1] : 1) + "</td> \
                        <td class=\"btn\"><a>Show</a></td> \
                    </tr>";

            var contests = DataStore.contest_list;
            for (var i in contests) {
                var contest = contests[i];
                var c_id = contest["key"];

                s += "<tr class=\"contest\" data-contest=\"" + c_id +"\"> \
                         <td class=\"name\">" + contest['name'] + "</td> \
                         <td class=\"score\">" + (self.contest_s[c_id].length > 0 ? round_to_str(self.contest_s[c_id][self.contest_s[c_id].length-1][1], contest["score_precision"]) : 0) + "</td> \
                         <td class=\"rank\">" + (self.contest_r[c_id].length > 0 ? self.contest_r[c_id][self.contest_r[c_id].length-1][1] : 1) + "</td> \
                         <td class=\"btn\"><a>Show</a></td> \
                      </tr>"

                var tasks = contest["tasks"];
                for (var j in tasks) {
                    var task = tasks[j];
                    var t_id = task["key"];

                    s += "<tr class=\"task\" data-task=\"" + t_id +"\"> \
                             <td class=\"name\">" + task['name'] + "</td> \
                             <td class=\"score\">" + (self.task_s[t_id].length > 0 ? round_to_str(self.task_s[t_id][self.task_s[t_id].length-1][1], task["score_precision"]) : 0) + "</td> \
                             <td class=\"rank\">" + (self.task_r[t_id].length > 0 ? self.task_r[t_id][self.task_r[t_id].length-1][1] : 1) + "</td> \
                             <td class=\"btn\"><a>Show</a></td> \
                          </tr>"
                }
            }

            self.navigator.html(s);

            self.active = null;

            $('tr.global td.btn', self.navigator).click();

            $("#UserDetail_bg").addClass("open");
        }
    };

    self.show_global = function () {
        self.title_label.text("Global");
        self.submission_table.html("");

        var intervals = new Array();
        var b = 0;
        var e = 0;

        for (var i = 0; i < DataStore.contest_list.length; i += 1) {
            b = DataStore.contest_list[i]["begin"];
            e = DataStore.contest_list[i]["end"];
            while (i+1 < DataStore.contest_list.length && DataStore.contest_list[i+1]["begin"] <= e) {
                i += 1;
                e = (e > DataStore.contest_list[i]["end"] ? e : DataStore.contest_list[i]["end"]);
            }
            intervals.push([b, e]);
        }

        self.draw_charts(intervals, DataStore.global_max_score,
                         self.global_s, self.global_r);
    };

    self.show_contest = function (contest_id) {
        var contest = DataStore.contests[contest_id];

        self.title_label.text(contest["name"]);
        self.submission_table.html("");

        self.draw_charts([[contest["begin"], contest["end"]]], contest["max_score"],
                         self.contest_s[contest_id], self.contest_r[contest_id]);
    };

    self.show_task = function (task_id) {
        var task = DataStore.tasks[task_id];
        var contest = DataStore.contests[task["contest"]];

        self.title_label.text(task["name"]);
        self.submission_table.html(self.make_submission_table(task_id));

        self.draw_charts([[contest["begin"], contest["end"]]], task["max_score"],
                         self.task_s[task_id], self.task_r[task_id]);
    };

    self.draw_charts = function (ranges, max_score, history_s, history_r) {
        var users = DataStore.user_count;

        Chart.draw_chart(self.score_chart, // canvas object
            0, max_score, 0, 0, // y_min, y_max, x_default, h_default
            ranges, // intervals
            history_s, // data
            [102, 102, 238], // color
            [max_score*1/4, // markers
             max_score*2/4,
             max_score*3/4]);
        Chart.draw_chart(self.rank_chart, // canvas object
            users, 1, 1, users-1, // y_min, y_max, x_default, h_default
            ranges, // intervals
            history_r, // data
            [210, 50, 50], // color
            [Math.ceil (users/12), // markers
             Math.ceil (users/4 ),
             Math.floor(users/2 )]);
    };

    self.make_submission_table = function (task_id) {
        var res = " \
<table> \
    <thead> \
        <tr> \
            <td>Time</td> \
            <td>Score</td> \
            <td>Token</td> \
            " + (DataStore.tasks[task_id]['extra_headers'].length > 0 ? "<td>" + DataStore.tasks[task_id]['extra_headers'].join("</td><td>") + "</td>" : "") + " \
        </tr> \
    </thead> \
    <tbody>";

        if (self.submissions[task_id].length == 0) {
            res += " \
        <tr> \
            <td colspan=\"" + (3 + DataStore.tasks[task_id]['extra_headers'].length) + "\">no submissions</td> \
        </tr>";
        } else {
            for (var i in self.submissions[task_id]) {
                var submission = self.submissions[task_id][i];
                time = submission["time"] - DataStore.contests[DataStore.tasks[task_id]["contest"]]["begin"];
                time = format_time(time);
                res += " \
        <tr> \
            <td>" + time + "</td> \
            <td>" + round_to_str(submission['score'], DataStore.tasks[task_id]['score_precision']) + "</td> \
            <td>" + (submission["token"] ? 'Yes' : 'No') + "</td> \
            " + (submission["extra"].length > 0 ? "<td>" + submission["extra"].join("</td><td>") + "</td>" : "") + " \
        </tr>";
            }
        }
        res += " \
    </tbody> \
</table>";
        return res;
    };

    self.hide = function () {
        $("#UserDetail_bg").removeClass("open");
    };
};
